<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<script type="text/javascript" src="../dist/cake-1.0.0.js"></script>
<script type="text/javascript" src="soundmanager2.js"></script>
<script type="text/javascript" src="support.js"></script>
<script language="JavaScript" type="text/javascript">
/*
CAKE - Canvas Animation Kit Experiment

Copyright (C) 2007  Ilmari Heikkinen

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/
  
  Effects = CakeJS.Klass({
    initialize : function(canvas, selectorElement, controlsElement) {
      this.selectorElement = selectorElement
      this.controlsElement = controlsElement
      this.canvasElement = canvas
      this.canvas = new CakeJS.Canvas(this.canvasElement)
      this.canvas.playOnlyWhenFocused = false
      var debug = E('div')
      var t0 = -1
      var frames = []
      var fc = E.canvas(200, 10)
      var fpsE = T('')
      var elapsedE = T('')
      var realFpsE = T('')
      var elapsedRealE = T('')
      E.append(debug, fpsE, ' fps (', elapsedE, ' ms to draw scene)', E('br'),
        realFpsE, ' real fps (', elapsedRealE, ' ms between draw calls)',
        E('br'), fc)
      var fctx = fc.getContext('2d')
      fctx.globalCompositeOperation = 'copy'
      fctx.fillStyle = 'white'
      this.canvas.updateFps = true
      this.canvas.addFrameListener(function(t) {
        if (this.updateFps) {
          fctx.drawImage(fc, -1, 0)
          fctx.clearRect(199, 0, 1, 10)
          fctx.fillRect(199, 0, 1, Math.min(100, this.currentRealFps) / 3.3)
          if (Math.floor(t / 500) != t0) {
            t0 = Math.floor(t / 500)
            var fps = (Math.floor(this.fps * 10)/10)
            var elapsed = Math.floor(1000 / this.fps)
            var realFps = (Math.floor(this.realFps * 10)/10)
            var elapsedReal = Math.floor(1000 / this.realFps)
            fpsE.textContent = fps
            elapsedE.textContent = elapsed
            realFpsE.textContent = realFps
            elapsedRealE.textContent = elapsedReal
          }
        }
      })
      this.effects = Effects.effects
      this.effectTitle = E('h3')
      var effect = location.hash.toString().slice(1)
      if (!effect || this.effects.indexOf(effect) == -1)
        effect = this.effects[0]
      this.setEffect(effect)
      this.controlPanel = new GuiConfig({
        object : this,
        container : this.selectorElement,
        controls : [
          ['effect', this.effects]
        ]
      })
      this.canvasControlPanel = new GuiConfig({
        object : this.canvas,
        container : this.selectorElement,
        controls : [
          'updateFps',
          'fixedTimestep',
          'drawBoundingBoxes',
          ['useMockContext', 'boolean', {title: "Use a mock drawing context <br>(i.e. turn off drawing. Useful for benchmarking the scenegraph.)"}]
        ]
      })
      this.screenShots = E('div', {className: 'Screenshots'})
      this.screenShotLink = E('a', 'Screenshot', {href: '#'})
      this.screenShots.appendChild(E('p', this.screenShotLink))
      var th = this
      this.screenShotLink.onclick = function(ev) {
        var data = th.canvasElement.toDataURL()
        var img = E('img', {
          src: data,
          width: 160,
          height: 120,
          title: 'Right-click to save, double-click to close'
        })
        img.addEventListener('dblclick', function(){
          this.parentNode.removeChild(this)
        }, false)
        th.screenShots.appendChild(img)
        if (ev.preventDefault) ev.preventDefault()
        return false
      }
      this.controlPanel.show()
      var pause = E('a', 'Pause', {href:"#"})
      pause.onclick = function(){
        if (this.isPlaying) {
          this.stop()
        } else {
          this.play()
        }
        return false
      }.bind(this.canvas)
      this.selectorElement.appendChild(pause)
      if (this.canvasElement.toDataURL)
        this.selectorElement.appendChild(this.screenShots)
      this.selectorElement.appendChild(debug)
      this.canvasControlPanel.show()
      this.selectorElement.appendChild(E('hr'))
      this.selectorElement.appendChild(this.effectTitle)
      $('sourceSubmit').onclick = function(ev) {
        try {
          eval($('sourceText').value)
          this.setEffect(this.effect, true)
          $('debug').innerHTML = ''
        } catch(e) {
          $('debug').innerHTML = e.toString()
        }
        return false
      }.bind(this)
    },
    
    setEffect : function(name, noSourceUpdate) {
      this.effect = name
      document.location.hash = "#"+name
      if (this.effectObject) {
        this.canvas.remove(this.effectObject.scene)
        this.effectObject.controlPanel.hide()
      }
      this.canvas.clear = true
      this.canvas.frameDuration = 30
      this.canvas.fill = false
      this.canvas.recording = false
      this.canvas.eventListeners = {}
      this.canvas.context = false
      this.canvas.showFpsHistogram = true
      this.canvas.redrawOnlyWhenChanged = false
      var Klass = window[name];
      this.effectObject = new CakeJS.Klass(this.canvas, this.controlsElement);
      this.canvas.append(this.effectObject.scene);
      this.effectTitle.innerHTML = name;
      this.effectObject.controlPanel.show();
      this.canvas.play();
      if (!noSourceUpdate) {
        $('sourceText').value = name + ' = CakeJS.Klass(Effect, ' +
                                Object.toSource(CakeJS.Klass.ancestors.last()) +
                                ')\n'
      }
    }
  })
  Effects.add = function(effect_name) {
    this.effects.splice(0,0,effect_name)
  }
  Effects.effects = []


  Effect = CakeJS.Klass({
    controls : [],
    description : 'An effect.',

    initialize : function(canvas, controlContainer) {
      this.canvas = canvas
      this.scene = new CakeJS.CanvasNode()
      this.scene.effect = this
      this.controlContainer = controlContainer
      this.controlPanel = new GuiConfig({
        object : this,
        container : this.controlContainer,
        description : this.description,
        controls : this.controls
      })
    }
  })


  ImageDataFill = CakeJS.Klass(Effect, {
    description : 'Plot 640x480 pixels in an array and draw them on the canvas with putImageData.',
    controls : ['generateData'],
    generateData : true,

    initialize : function(canvas, cc) {
      Effect.initialize.call(this, canvas, cc)
      this.canvas.fillStyle = 'black'
      this.canvas.fill = true
      var c = canvas.getContext()
      var support = c.putImageData && c.getImageData
      if (support) {
        if (!c.createImageData) {
          c.createImageData = function(w,h){
            var d = c.getImageData(0,0,w,h)
            if (d.data.length != w*h*4) { // We're screwed, thanks a lot.
              var ratio = d.data.length / (w*h*4)
              w *= ratio
              h *= ratio
              d = c.getImageData(0,0,w,h)
            }
            return d
          }
        }
        // Let's try it out. Should work.
        var d = c.createImageData(1,1)
        if (!d.setData) {
          d.setData = function(data) {
            for (var i=0; i<data.length; i++) {
              this.data[i] = data[i]
            }
          }
        }
        d.setData([255, 0, 255, 255])
        c.putImageData(d, 0, 0)
        var idata = c.getImageData(0,0,1,1)
        if (![255, 0, 255, 255].equals(idata.data)) {
          support = false // Lies. Dirty lies.
        }
      }
      if (!support) {
        var msg = "Your browser doesn't support putImageData."
        var notSupported = new ElementNode(E('div',
          msg,
          {style: {color:'white', textAlign:'center'}}
        ), {x:320, y:240, align:'center', valign:'center'})
        this.scene.append(notSupported)
        return
      }
      this.scene.imageData = c.createImageData(640, 480)
      this.scene.draw = function(ctx) {
        var pixels = this.imageData.data
        var r = Math.floor(Math.random() * 256)
        var g = Math.floor(Math.random() * 256)
        var b = Math.floor(Math.random() * 256)
        if (this.effect.generateData) {
          for (var i=0; i<640*480*4; i++) {
            pixels[i] = r
            pixels[++i] = g
            pixels[++i] = b
            pixels[++i] = 255
          }
        }
        ctx.putImageData(this.imageData, 0, 0)
      }
    }
  })
  Effects.add('ImageDataFill')


  RectangleWave = CakeJS.Klass(Effect, {
    description : 'Spinning rectangle following a sine wave. Use fixed timestep for smooth traces.',
    controls : [
      'spin',
      'centered',
      'scale',
      'stroke',
      'fill',
    ],
    spin : false,
    centered : false,
    scale : false,
    stroke : false,
    fill : true,
    
    initialize : function(canvas, controlContainer) {
      Effect.initialize.call(this, canvas, controlContainer)
      this.canvas.fill = 'rgba(0,0,0,0.1)'
      var g1 = new Gradient({
        endX : 0, endY : 0,
        endRadius : 60,
        type : 'radial',
        colorStops : [
          [0, 'rgba(0,255,255,0)'],
          [0.5, 'rgba(0,255,255,0.3)'],
          [0.75, '#00ffff'],
          [0.85, 'rgba(255,0,0,1)'],
          [1, 'rgba(0,0,0,0)']
        ]
      })
      this.fillStyle = g1
      this.strokeStyle = '#00ffff'
      var rect = this.makeRect(0, g1)
      this.scene.append(rect)
    },

    makeRect : function(offset, color) {
      var scene = new CanvasNode()
      var rect = new Rectangle()
      var elem = new ElementNode(
        E('div', "Rectangle", {style: {color:'white'}}) )
      elem.valign = 'bottom'
      elem.align = 'right'
      var th = this
      rect.addFrameListener(function(t){
        t += offset
        t*=0.25
        rect.fill = th.fill ? th.fillStyle : false
        rect.stroke = th.stroke ? th.strokeStyle : false
        if (th.scale) {
          this.strokeWidth = 1.5
          elem.x = elem.y = this.width = this.height = 30
          this.scale = (Math.cos(t/200)+1.5)
        } else {
          this.scale = 1
          this.strokeWidth = 2
          elem.x = elem.y = this.width = this.height = (Math.cos(t/200)+2) * 30
        }
        this.centered = th.centered
        this.rotation = (t / (th.spin ? -50 : 200)) % (Math.PI * 2)
      })
      rect.append(elem)
      scene.addFrameListener(function(t) {
        t += offset
        t *= 0.25
        this.x = -80 + ((t/5) % 800)
        this.y = 220 + Math.sin(t/200) * 100
      })
      scene.append(rect)
      return scene
    }
  })
  Effects.add('RectangleWave')


  Circles = CakeJS.Klass(Effect, {
    description : 'Circles on a sine wave. Use fixed timestep for smooth traces.',
    controls : [
      'stroke',
      'fill',
      'blur'
    ],
    stroke : false,
    fill : true,
    blur : true,

    blurFill : 'rgba(0,0,0, 0.1)',
    normalFill : 'rgba(0,0,50, 1)',
    
    circleGradient : {
      type : 'radial',
      endRadius : 15,
      colorStops : [
        [ 0.0, "rgba(100,195,90,1)" ],
        [ 0.2, "rgba(5,10,80,0.4)" ],
        [ 1, "rgba(10,0,40,0)" ]
      ]
    },
    
    initialize : function(canvas, controlContainer) {
      Effect.initialize.call(this, canvas, controlContainer)
      this.canvas.fill = this.blurFill
      for (var i=0; i<20; i++)
        this.scene.append(this.makeCircle((i/20) * 4 * Math.PI))
      this.scene.strokeWidth = 3
      this.scene.rotation = [0.05, this.canvas.width/2, this.canvas.height/2]
      this.scene.compositeOperation = 'lighter'
      this.scene.fill = new Gradient(this.circleGradient)
      this.scene.stroke = '#ffeeaa'
    },

    makeCircle : function(offset) {
      var circle = new Circle(15)
      circle.circles = this
      circle.offset = offset
      circle.addFrameListener(this.circleMotion)
      return circle
    },

    circleMotion : function(t) {
      this.fill = this.circles.fill
      this.stroke = this.circles.stroke
      var trw = this.root.width+160
      this.x = -50 + ((t/15 + (this.offset / (4*Math.PI) * trw)) % trw)
      this.y = this.root.height*0.5 + Math.sin(this.offset + t/400) * 20
      this.scale = 1.5+Math.cos(this.offset*Math.PI*4 + t/1600)
    },

    setBlur : function(blur) {
      this.blur = blur
      this.canvas.fill = (this.blur ? this.blurFill : this.normalFill)
    }
  })
  Effects.add('Circles')

  
  ClipTest = CakeJS.Klass(Effect, {
    description : 'Two rectangles clipped by a circle.',

    initialize : function(canvas, controlContainer) {
      Effect.initialize.call(this, canvas, controlContainer)
      this.bgCircle = new Circle(120)
      this.bgCircle.x = 320
      this.bgCircle.y = 240
      this.bgCircle.zIndex = -1
      this.bgCircle.stroke = false
      this.bgCircle.fill = new Gradient({
        type : 'radial',
        startX : 0, startY: 0,
        endX : 0, endY : 0,
        endRadius: 120,
        colorStops : [
          [0, [0,0,0,0.3]],
          [0.8, [0,0,0,0.5]],
          [0.9, [0,0,0,0.8]],
          [1, [0,0,0,0]]
        ]
      })
      this.clipRect = new Circle()
      this.clipRect.x = 320
      this.clipRect.y = 240
      this.clipRect.clip = true
      this.clipRect.stroke = true
      this.clipRect.fill = false
      this.clipRect.radius = 100
      this.rect = new Rectangle()
      this.rect.width = 150
      this.rect.height = 40
      this.rect.fill = true
      this.rect.stroke = false
      this.rect2 = new Rectangle()
      this.rect2.width = 40
      this.rect2.height = 150
      this.rect2.fill = true
      this.rect2.stroke = false
      this.rect2.rotation = Math.PI
      this.rectTop = new CanvasNode()
      this.clipRect.addFrameListener(function(t) {
        this.opacity = 0.7 + 0.3*Math.sin(t / 800)
      })
      this.rectTop.addFrameListener(function(t) {
        this.rotation = (t / 400) % (Math.PI * 2)
        this.x = Math.cos(t / 300) * 20
        this.y = Math.sin(t / 400) * 50
      })
      this.rectTop.append(this.rect, this.rect2)
      this.clipRect.append(this.rectTop)
      this.scene.append(this.clipRect, this.bgCircle)
      var g = new Gradient({
        type : 'radial',
        endX : 0, endY : 0,
        endRadius : 150,
        colorStops : [
          [0, '#00ffff'],
          [1, 'rgba(0,0,0,0)']
        ]
      })
      this.scene.fill = g
      this.scene.stroke = g
      this.scene.strokeWidth = 10
    }
  })
  Effects.add('ClipTest')

  
  ImageTest = CakeJS.Klass(Effect, {
    description : 'Image flying around while scaling, rotating and changing its opacity.',
    controls : [
      'fill',
      'stroke',
      ['usePattern', 'boolean', {title: "Use pattern for drawing the image<br>(faster on Firefox 2, breaks opacity on Firefox)"}]
    ],
    
    fill : false,
    stroke : true,
    usePattern : false,
    
    initialize : function(canvas, controlContainer) {
      if (!this.scene) {
        this.image = Object.loadImage('redhairgreeneyes3.jpg')
        Effect.initialize.call(this, canvas, controlContainer)
      }
      if (!Object.isImageLoaded(this.image)) {
        setTimeout(function(){
          if (this.scene.parent)
            this.initialize()
        }.bind(this), 200)
        return
      }
      this.imageNode = new ImageNode(this.image)
      this.topNode = new CanvasNode()
      this.topNode.stroke = 'rgba(0,255,255,0.5)'
      this.topNode.strokeWidth = 10
      this.imageNode.stroke = this.stroke
      this.imageNode.fill = this.fill
      this.topNode.addFrameListener(function(t) {
        this.x = 150 + Math.sin(t / 300) * 150
        this.y = 120 - Math.sin(t / 500) * 150
        this.scale = 0.6 + (Math.sin(t / 500) / 2)
        this.opacity = this.scale - 0.1
        this.rotation = Math.cos(t / 900) * 0.3 * Math.PI
      })
      this.topNode.append(this.imageNode)
      this.scene.append(this.topNode)
    },

    setStroke : function(img) {
      this.imageNode.stroke = this.stroke = img
    },
    
    setFill : function(img) {
      this.imageNode.fill = this.fill = img
    },
    
    setUsePattern : function(img) {
      this.imageNode.usePattern = this.usePattern = img
    }
  })
  Effects.add('ImageTest')
  
  
  PathTest = CakeJS.Klass(Effect, {
    description : 'Simple path, filled and stroked.',
    controls : ['stroke', 'fill', 'closePath'],
    stroke : true,
    fill : true,
    closePath : false,
    
    initialize : function(canvas, controlContainer) {
      Effect.initialize.call(this, canvas, controlContainer)
      rect = new Path([
        ['moveTo', [-50, -50]],
        ['lineTo', [-50, 0]],
        ['lineTo', [0, 50]],
        ['bezierCurveTo', [-10, 20, 0, 30, 50, 50]],
        ['quadraticCurveTo', [0,0, 0, -50]]
      ])
      rect.scale = 2
      this.rectTop = new CanvasNode()
      var th = this
      this.rectTop.addFrameListener(function(t) {
        rect.fill = th.fill
        rect.stroke = th.stroke
        rect.closePath = th.closePath
        this.rotation = (t / 400) % (Math.PI * 2)
        this.x = 320 + Math.cos(t / 300) * 20
        this.y = 240 + Math.sin(t / 400) * 50
      })
      this.rectTop.append(rect)
      this.scene.append(this.rectTop)
      var g = new Gradient({
        type : 'radial',
        endX : 0, endY : 0,
        endRadius : 150,
        colorStops : [
          [0, '#00ffff'],
          [1, 'rgba(0,0,0,0)']
        ]
      })
      this.scene.fill = g
      this.scene.stroke = 'rgba(0,255,255,0.5)'
      this.scene.strokeWidth = 10
    }
  })
  Effects.add('PathTest')


  ZTest = CakeJS.Klass(Effect, {
    description : 'Z-sort test. The red line should be above the cyan gradient, and the red oval should be below the cyan gradient.',

    initialize : function(canvas, controlContainer) {
      Effect.initialize.call(this, canvas, controlContainer)
      var g = new Gradient({
        type : 'radial',
        endX : 0, endY : 0,
        startRadius : 5,
        endRadius : 100,
        colorStops : [
          [0, '#ff0000'],
          [0.2, '#00ffff'],
          [1, 'rgba(0,0,0,0)']
        ]
      })
      var g2 = new Gradient({
        endX : 200, endY : 0,
        colorStops : [
          [0, '#ff0000'],
          [1, 'rgba(255,0,0,0)']
        ]
      })
      this.redNode = new Rectangle(200,5)
      this.redNode.y = -2.5
      this.redNode.fill = g2
      this.redNode.zIndex = 10
      this.greenNode = new Circle(100)
      this.greenNode.fill = g
      this.greenNode.zIndex = 5
      this.yellowNode = new Circle(50)
      this.yellowNode.scale = [0.7, 1.2]
      this.yellowNode.fill = '#ff0000'
      this.yellowNode.zIndex = 1
      this.topNode = new CanvasNode()
      this.topNode.append(this.redNode, this.greenNode, this.yellowNode)
      this.topNode.addFrameListener(function(t) {
        this.x = 320 + Math.sin(t / 300) * 150
        this.y = 240 - Math.sin(t / 500) * 150
        this.scale = 0.8 + (Math.sin(t / 500) / 4)
        this.rotation = ((t / 1000) * (2*Math.PI)) % (2*Math.PI)
      })
      this.scene.append(this.topNode)
    }
  })
  Effects.add('ZTest')


  Stars = CakeJS.Klass(Effect, {
    description: 'Stars twinkling on an optionally cloudy optionally animated sky. With an optional fancy glow around a star.',
    controls : [
      'clouds',
      'backgroundGradient',
      ['starCross', 'boolean', {title: 'Star cross (hover over a star to move)'}]
    ],
    clouds : true,
    backgroundGradient : true,
    starCross : false,
    
    initialize : function(aniCanvas, controlContainer) {
      Effect.initialize.apply(this, arguments)
      this.cloudImage = Object.loadImage('cloud_mask.png')
      this.bgGradient = new Gradient({
        endX : -20, endY : 500,
        colorStops : [
          [0, [10, 0, 50]],
          [1, [0, 20, 70]]
        ]
      })
      this.bgColor = 'rgba(15, 0, 40, 1)'
      this.canvas.fill = this.backgroundGradient ? this.bgGradient : this.bgColor
      var v = 50
      var s = 1
      this.scene.addFrameListener(function(t) {
        if (aniCanvas.fill.colorStops) {
          var h = 210 + 120*(Math.sin(t / 1000)*0.5 + 0.5)
          if (h < 0)
            h += 360
          var h2 = h - 30
          if (h2 < 0)
            h2 += 360
          aniCanvas.fill.colorStops[0][1] = Colors.hsv2rgb(h, s, v)
          aniCanvas.fill.colorStops[1][1] = Colors.hsv2rgb(h2, s, v)
          aniCanvas.fill.compiled = false
        }
      })
      this.cloudMask = new ImageNode(this.cloudImage)
      this.cloudMask.zIndex = -1
      this.cloudMask.opacity = 0.6
      this.cloudMask.visible = this.clouds
      this.scene.append(
        this.cloudMask,
        this.makeStar(140, 120, 255, 19, 60, 40),
        this.makeStar(100, 120, 255, 16, 150, 250),
        this.makeStar(255, 255, 120, 14, 560, 190),
        this.makeStar(200, 165, 145, 15, 350, 310),
        this.makeStar(255, 20, 200, 23, 250, 100),
        this.makeStar(200, 75, 200, 26, 450, 360)
      )
      this.curves = new CanvasNode()
      this.curves.visible = this.starCross
      this.curves.append(
        this.makeCurve(255,0,200,0.2, Math.PI * 0.25),
        this.makeCurve(255,0,200,0.2, Math.PI * 0.75),
        this.makeCurve(255,0,200,0.2, Math.PI * 1.25),
        this.makeCurve(255,0,200,0.2, Math.PI * 1.75)
      )
      this.curves.x = 250
      this.curves.y = 100
      this.curves.zIndex = -0.5
      this.scene.append(this.curves)
    },

    setClouds : function(c) {
      this.clouds = this.cloudMask.visible = c
    },

    setBackgroundGradient : function(g) {
      this.backgroundGradient = g
      if (this.backgroundGradient) {
        this.canvas.fill = this.bgGradient
      } else {
        this.canvas.fill = this.bgColor
      }
    },

    setStarCross : function(c) {
      this.starCross = this.curves.visible = c
    },

    makeCurve : function(r,g,b,a,rotation) {
      var curve = new Path([
        ['moveTo', [-180, -100]],
        ['bezierCurveTo', [-100, -100, 0, 0, 0, 0]],
        ['bezierCurveTo', [0, 0, -100, 100, -180, 100]]
      ])
      curve.fill = new Gradient({
        type : 'radial',
        endY : 0, endX : 0,
        endRadius : 150,
        colorStops : [
          [0, [r,g,b,a]],
          [0.3, [r,g,b,a*0.3]],
          [0.35, [r,g,b,0]],
          [0.37, [r,g,b,a*0.3]],
          [1, [r,g,b,0]]
        ]
      })
      curve.rotation = 0.6 + rotation
      return curve
    },

    makeStar : function(r,g,b, radius, x, y) {
      var g1 = new Gradient({
        type : 'radial',
        endX : 0, endY : 0,
        startRadius : 0,
        endRadius : radius,
        colorStops : [
          [0,   [r+100,g+100,b+100,1]],
          [0.3, [r,g,b, 0.5]],
          [0.4, [r,b,g, 0.8]],
          [0.5, [r,g,b, 0.4]],
          [0.6, [r,g,b, 0.7]],
          [1,   [r,g,b, 0]]
        ]
      })
      var g2 = new Gradient({
        type : 'radial',
        endX : 0, endY : 0,
        startRadius : 0,
        endRadius : radius / 2,
        colorStops : [
          [0,   [255,255,255, 1]],
          [0.3, [r,g,b, 0.3]],
          [0.8, [r-40,g-20,b+20, 0.0]],
          [0.9, [r,g,b, 0.1]],
          [1,   [r,g,b, 0]]
        ]
      })
      var star = new CanvasNode()
      var spokes = new CanvasNode()
      spokes.fill = g1
      var spoke1 = new Rectangle(radius*2,1)
      spoke1.centered = true
      var spoke2 = new Rectangle(1,radius*2)
      spoke2.centered = true
      var glow = new Circle(radius / 2)
      glow.fill = g2
      glow.zIndex = 1
      spokes.append(spoke1, spoke2)
      star.append(spokes, glow)
      var offset = Math.random() * 800
      star.rotating = false
      var th = this
      star.addFrameListener(function(t){
        var off = (0.2 + Math.sin(Math.pow(Math.random(),2) + (offset+t)/400)*0.2)
        this.scale = 0.8 + off
        this.opacity = 1 - (off/2)
        if (this.rotating) {
          if (this.rotation < 0.6 && this.rotation + 0.5 >= 0.6) {
            this.rotation = 0.6
            this.rotating = false
          } else {
            this.rotation += 0.5
            this.rotation = this.rotation % (Math.PI)
          }
        } else if (Math.random() < 0.002) {
          this.rotating = true
        }
        if (this.underCursor && this.contains(this.root.target)) {
          th.curves.x = this.x
          th.curves.y = this.y
        }
      })
      star.x = x
      star.y = y
      star.zIndex = 0
      star.rotation = 0.6
      return star
    }
  })
  Effects.add('Stars')


  Polaroids = CakeJS.Klass(Effect, {
    description : 'Plunging the depths of "Heavier! Slower! More Gradients! Blow up, my CPU!" with a small slideshow.',
    controls : [
      ['usePattern', 'boolean', {title: "Use pattern for drawing images <br>(faster on Firefox 2, breaks opacity on Firefox)"}],
      ['showImages', 'boolean'],
      ['polaroidDropShadows', 'boolean', {title: 'Matte drop shadows (only on Safari)'}],
      ['polaroidOpacity', '0.0..1.0'],
      ['imageOpacity', '0.0..1.0'],
      ['matteOpacity', '0.0..1.0'],
      ['gradientMatte', 'boolean', {title: 'Gradient matte (breaks matte opacity on Firefox)'}],
      ['transparentBackground', 'boolean'],
      ['compositeOperation', ['source-over', 'lighter', 'copy', 'xor']],
      ['showText', 'boolean', {title: 'Show text (only on Firefox 3)'}],
      ['textAsPath', 'boolean'],
      ['strokeText', 'boolean'],
      ['fillText', 'boolean']
    ],
    z : 0,
    usePattern : false,
    showImages : true,
    strokeText : false,
    fillText : true,
    textAsPath : true,
    showText : true,
    polaroidDropShadows : true,
    polaroidOpacity : 1.0,
    transparentBackground : true,
    gradientMatte : false,
    imageUrls : [1,2,3,4,5,6,7,8].map(function(e) {
      return 'polaroids/'+e+'.jpg'
    }),

    loadImages : function() {
      this.images = this.imageUrls.map(function(e) {
        return Object.loadImage(e)
      })
    },
    
    initialize : function(aniCanvas, controlContainer) {
      Effect.initialize.apply(this, arguments)
      var bgColor = 'rgba(80,70,60,1)'
      aniCanvas.fill = this.transparentBackground ? false : bgColor
      this.loadImages()
      this.topNode = new CanvasNode()
      var t0 = 0
      var th = this
      this.topNode.addFrameListener(function(t) {
        t *= 2
        if (Math.floor(t / 6000) > t0) {
          t0 = Math.floor(t / 6000)
          th.rotateImages()
        }
        th.canvas.fill = th.transparentBackground ? false : bgColor
      })
      this.scene.append(this.topNode)
    },

    makePolaroid : function(image, z) {
      var polaroid = new CanvasNode()
      polaroid.cursor = 'pointer'
      polaroid.addEventListener('click', function() {
        window.open(image.src, '_blank')
      }, false)
      var imageNode = new ImageNode(image)
      imageNode.x = 8
      imageNode.y = 8
      var imageShadow = new Rectangle()
      imageShadow.stroke = 'rgba(0,0,0,0.5)'
      imageShadow.x = 8
      imageShadow.y = 8
      imageShadow.stroke = true
      imageShadow.strokeWidth = 2
      imageShadow.zIndex = -0.5
      var hilight = new Rectangle()
      hilight.x = 8
      hilight.y = 8
      hilight.fill = 'rgba(255,255,0,0.2)'
      hilight.zIndex = 2
      hilight.compositeOperation = 'lighter'
      hilight.visible = false
      var matte = new Rectangle(10, 10)
      matte.zIndex = -1
      matte.fill = true
      var matteColor = 'rgba(220,215,210,1)'
      var matteGradient = new Gradient({
        startY : 320,
        endX : 0, endY : 368,
        colorStops : [
          [0, 'rgba(255,255,255,0.1)'],
          [0.2, 'rgba(155,155,155,0.1)'],
          [0.25, 'rgba(255,255,255,1)'],
          [0.27, 'rgba(135,145,155,1)'],
          [0.93, 'rgba(135,125,115,1)'],
          [0.95, 'rgba(155,145,135,1)'],
          [1, 'rgba(35,25,15,1)']
        ]
      })
      var strokeColor = 'rgba(255,255,255,0.1)'
      var strokeGradient = new Gradient({
        startY : 0,
        endX : 0, endY : 368,
        colorStops : [
          [0, 'rgba(255,255,255,0.1)'],
          [0.95, 'rgba(255,255,255,0.1)'],
          [1, 'rgba(0,0,0,0.2)']
        ]
      })
      matte.stroke = strokeColor
      matte.shadowBlur = 8
      matte.shadowOffsetX = 0
      matte.shadowOffsetY = 2
      var black70 = 'rgba(0,0,0,0.7)'
      matte.shadowColor = black70
      matte.strokeWidth = 2
      var text = new TextNode(image.src.split("/").last())
      text.x = 8
      text.font = 'bold 24px URW Gothic L, Sans-Serif'
      text.fill = 'rgba(255,255,255,0.5)'
      var text2 = Object.clone(text)
      text2.zIndex = 2
      text2.fill = 'rgba(0,0,0,0.8)'
      var onload = function() {
        matte.width = image.width + 16
        matteGradient.startY = image.height
        matte.height = matteGradient.endY = image.height + 48
        strokeGradient.startY = matteGradient.startY
        strokeGradient.endY = matteGradient.endY
        strokeGradient.compiled = false
        matteGradient.compiled = false
        text.y = image.height + 37
        text2.y = text.y-1
        hilight.width = imageShadow.width = image.width
        hilight.height = imageShadow.height = image.height
        polaroid.x = -matte.width / 2
        polaroid.y = 16
      }
      image.onload = onload
      if (Object.isImageLoaded(image))
        onload()
      polaroid.append(matte, imageShadow, imageNode, text, text2, hilight)
      var topNode = new CanvasNode()
      topNode.append(polaroid)
      var t0
      var th = this
      topNode.addFrameListener(function(t) {
        imageNode.usePattern = th.usePattern
        imageNode.visible = th.showImages
        text.visible = th.showText
        text.stroke = th.strokeText
        text2.visible = th.showText && !text.stroke
        text.asPath = th.textAsPath
        imageNode.opacity = th.imageOpacity
        matte.opacity = th.matteOpacity
        matte.fill = th.gradientMatte ? matteGradient : matteColor
        matte.stroke = th.gradientMatte ? strokeGradient : strokeColor
        matte.shadowColor = th.polaroidDropShadows ? black70 : 'transparent'
        if (!t0) t0 = t
        t = (t-t0)
        hilight.visible = this.underCursor && this.contains(this.root.target)
        if (text2.underCursor && hilight.visible) {
          text2.fill = 'rgba(105,75,0,1)'
          text2.shadowColor = 'rgba(200,100,0,0.9)'
          text2.shadowBlur = 8
          text2.compositeOperation = 'lighter'
        } else {
          text2.fill = 'rgba(0,0,0,0.8)'
          text2.shadowColor = 'rgba(0,0,0,0)'
          text2.shadowBlur = 0
          text2.compositeOperation = undefined
        }
        if (!th.fillText) {
          text.fill = text2.fill = false
        } else {
          text.fill = 'rgba(255,255,255,0.5)'
        }
        this.compositeOperation = th.compositeOperation
        this.opacity = th.polaroidOpacity
        this.scale = 1 - 0.8*(Math.min(1, t / 24000))
        this.x = 320 + this.scale * -Math.cos(t / 500) * 50
        this.y = 50 + this.scale * Math.sin(t / 500) * 50
        if (t < 1000) {
          var fac = 1 - t / 1000
          this.x += -800 * fac
          this.y += -850 * fac
          this.scale += 3 * fac
        }
        this.rotation = Math.sin(t / 500 + 0.15*Math.PI) * this.scale * 0.3 * Math.PI
      })
      topNode.zIndex = z
      return topNode
    },

    rotateImages : function() {
      if (Object.isImageLoaded(this.images[0])) {
        var image = this.images.rotate()
        this.z += 1
        this.topNode.append(this.makePolaroid(image, this.z))
        if (this.topNode.childNodes.length > 8) {
          this.topNode.remove(this.topNode.childNodes[0])
        }
      }
    }
  })
  Effects.add('Polaroids')


  Accumulation = CakeJS.Klass(Effect, {
    description : 'A growing endless pile of stuff.',
    controls : [
      ['compositeOperation', [
        'random',
        'source-over',
        'lighter',
        'copy',
        'source-atop',
        'destination-over',
        'xor',
        'darker'
      ]],
      'clearBrush'
    ],
    
    compositeOperation : 'random',
    clearBrush : false,
  
    initialize : function(c,cc) {
      Effect.initialize.apply(this, arguments)
      this.canvas.fill = false
      var canvasElem = E.canvas(this.canvas.width, this.canvas.height)
      var bgCanvas = this.bgCanvas = new Canvas(
        canvasElem, {
          isPlaying : false,
          clear : false,
          changed : true,
          redrawOnlyWhenChanged : true
        }
      )
      this.bgNode = new ImageNode(this.bgCanvas.canvas)
      this.scene.append(this.bgNode)
      this.bgNode.addFrameListener(bgCanvas.onFrame.bind(bgCanvas))
      this.bgNode.zIndex = -1
      var rect = new Rectangle(100,100)
      rect.fill = [0,0,0,0.5]
      var scene = this.scene
      rect.cX = rect.ncX = 320
      rect.cY = rect.ncY = 240
      rect.scale = rect.nscale = 1
      this.composites = this.controls[0][1].slice(1)
      var th = this
      rect.addFrameListener(function(t) {
        if (Math.random() < 0.01) {
          this.ncX = 50 + Math.random() * 540
          this.ncY = 50 + Math.random() * 240
          th.randomizeBrush()
          this.nscale = Math.random() * 2
          this.ncY = Math.min(this.ncY, 380 - Math.sqrt(2)*this.nscale*100)
        }
        if (th.clearBrush) {
          this.fillStyle[3] = 0
          this.compositeOperation = 'copy'
        } else if (th.compositeOperation != 'random') {
          this.compositeOperation = th.compositeOperation
        }
        this.cX += ((th.canvas.mouseX || this.ncX) - this.cX) * 0.02
        this.cY += ((th.canvas.mouseY || this.ncY) - this.cY) * 0.02
        this.scale += (this.nscale - this.scale) * 0.02
        this.x = this.cX + Math.sin(t / 800) * 60
        this.y = this.cY + Math.cos(t / 800) * 60
        this.rotation = (t / 200) % (Math.PI * 2)
      })
      bgCanvas.addFrameListener(function(t) {
        if (rect.parent == this) {
          rect.removeSelf()
          th.scene.append(rect)
        } else if (th.clearBrush || Math.random() < 0.1) {
          rect.removeSelf()
          this.append(rect)
          this.changed = true
        }
      })
      this.rect = rect
      this.scene.append(rect)
    },

    randomizeBrush : function() {
      this.rect.fill = [Math.floor(Math.random()*255), Math.floor(Math.random()*255), Math.floor(Math.random()*255), 0.2 + Math.random()*0.6]
      if (this.compositeOperation == 'random') {
        this.rect.compositeOperation = this.composites.pick()
      }
    },

    setClearBrush : function(cb) {
      this.clearBrush = cb
      this.randomizeBrush()
    }
  })
  Effects.add('Accumulation')

  
  Branches = CakeJS.Klass(Effect, {
    description : 'Growing tree branches.',
    controls : [ 'jitter', 'modulateThickness' ],
    jitter : true,
    modulateThickness : false,

    initialize : function(canvas, cc) {
      Effect.initialize.call(this, canvas, cc)
      this.canvas.fill = 'white'
      var rect = new Rectangle(640,480, {
        fillStyle : 'rgba(255,255,255,0.8)',
        zIndex : -1
      })
      var circle = new Circle(10, {
        fill : 'rgba(155, 0, 0, 1)',
        x : 0,
        y : 490,
        scale : 0,
        motionVector : {x: Math.random(), y: Math.random()}
      })
      circle.effect = this
      circle.rect = rect
      circle.growTree = this.growTree
      circle.addFrameListener(circle.growTree)
      this.scene.append(circle)
      this.scene.append(rect)
    },

    growTree : function(t, dt) {
      if (this.scale < 0.2) {
        if (this.rect) {
          this.rect.fill = this.rect.fillStyle
          this.parent.childNodes = [this, this.rect]
        } else {
          this.removeSelf()
          return
        }
        this.motionVector.x = Math.random() * 5
        this.motionVector.y = Math.random()
        this.x = 0
        this.y = 0 + Math.random() * 100
        this.scale = 1
      } else {
        this.root.clear = false
        if (this.rect)
          this.rect.fill = false
        this.x += this.motionVector.x
        this.y += this.motionVector.y
        if (this.effect.jitter) {
          this.x += (Math.random() - 0.5)
          this.y += (Math.random() - 0.5)
        }
        if (this.effect.modulateThickness)
          this.radius = (12 + 2 * Math.sin(t / 250) + Math.random())
        this.scale -= 0.003
        if (Math.floor(this.scale * 15) != this.lastScale) {
          this.lastScale = Math.floor(this.scale * 15)
          if (Math.random() < 0.3) {
            var circle = new Circle(10, {
              fill : this.fill,
              x : this.x,
              y : this.y,
              scale : this.scale * 0.8,
              lastScale : Math.floor(this.scale*0.8*15),
              motionVector : {x: -this.motionVector.y, y: this.motionVector.x}
            })
            if (Math.random() < 0.5) {
              circle.motionVector.x *= -1
              circle.motionVector.y *= -1
            }
            circle.effect = this.effect
            circle.growTree = this.growTree
            circle.addFrameListener(circle.growTree)
            this.parent.append(circle)
          }
          var a = Math.random() * Math.PI * 0.5
          this.motionVector.x = Math.cos(a) * 3
          this.motionVector.y = Math.sin(a) * 2
        }
      }
    }
  })
  Effects.add('Branches')


  Picking = CakeJS.Klass(Effect, {
    description : "Mouse picking test. Shapes should turn red when hovered. Browsers without isPointInPath (e.g. Safari, Opera 9.2) use an inaccurate bounding box test for complex paths (the hand in the picture.)",
    
    initialize : function(canvas, cc) {
      Effect.initialize.call(this, canvas, cc)
      var simple = this.makeRect()
      var rotated = this.makeRect()
      rotated.rotation = Math.PI/4
      rotated.x = 47
      var scaled = this.makeRect()
      scaled.x = 80
      scaled.scale = 2
      var scaled2 = this.makeRect()
      scaled2.x = 140
      scaled2.scale = [1, 2]
      var scaled3 = this.makeRect()
      scaled3.x = 180
      scaled3.scale = [2, 1]
      var nested1 = new CanvasNode()
      nested1.x = 120
      nested1.y = 140
      var n2 = new CanvasNode()
      n2.rotation = Math.PI/2.8
      var n3 = new CanvasNode()
      n3.scale = 4
      var r = this.makeRect()
      r.cx = 50
      r.origFillStyle = 'rgba(240,130,0,1)'
      r.centered = true
      var r2 = this.makeRect()
      r2.cx = 82
      r2.origFillStyle = 'rgba(200,0,0,1)'
      r2.centered = true
      r2.scale = 0.6
      r.append(r2)
      n3.append(r)
      n2.append(n3)
      nested1.append(n2)
      var c1 = this.makeCircle(150, 140)
      c1.strokeWidth = 12
      var c2 = this.makeCircle(370, 120)
      c2.cy = 100
      c2.strokeWidth = 18
      var b1 = this.makeRect()
      var b2 = this.makeRect()
      b1.width = 150
      b1.height = 40
      b1.centered = true
      b1.zIndex = 1
      b1.origFillStyle = 'black'
      b1.x = 380
      b1.y = 170
      b2.width = 150
      b2.height = 40
      b2.centered = true
      b2.zIndex = 1
      b2.origFillStyle = 'black'
      b2.x = 180
      b2.y = 95
      b2.rotation = Math.PI/4
      var bc = this.makeCircle(170,300)
      bc.rotation = Math.PI/7
      bc.scale = [5,10]
      bc.zIndex = -1
      bc.origFillStyle = 'rgba(240,220,10,1)'
      var hand = new Path(
      [
        ["moveTo", [-10, 30]],
        ["quadraticCurveTo", [45, -200, 70, -80]],
        ["quadraticCurveTo", [110, -90, 90, -50]],
        ["quadraticCurveTo", [130, -50, 100, -20]],
        ["quadraticCurveTo", [130, -10, 110, 10]]
      ], {
        rotation: Math.PI/10,
        x : 450,
        y : 480,
        closePath: true,
        stroke: true,
        strokeMode: 'below',
        strokeWidth: 40,
        origFillStyle: 'rgba(240,220,10,1)'
      })
      hand.addFrameListener(this.hoverRed)
      bc.addFrameListener(function(t) {
        if (this.underCursor && this.root.target == this) {
          hand.origFillStyle = 'red'
          b2.rotation = Math.PI/4
          b1.rotation = 0
          b2.cx = b1.cx = b2.cy = b1.cy = 0
          this.parent.x = (Math.random() - 0.5) * 5
          this.parent.y = (Math.random() - 0.5) * 5
          this.parent.rotation = -this.parent.rotation
        } else if (this.root.target != b2 && this.root.target != b1 &&
          !headband.contains(this.root.target) && this.root.target != c1 && this.root.target != c2 && !nested1.contains(this.root.target)  ) {
          b2.rotation = 0
          b2.cx = -10
          b2.cy = -50
          b1.rotation = Math.PI/4
          b1.cx = 10
          b1.cy = -50
          hand.origFillStyle = this.origFillStyle
          this.parent.x = 0
          this.parent.y = 0
          this.parent.rotation = 0.01
        } else {
          hand.origFillStyle = this.origFillStyle
        }
      })
      var headband = new CanvasNode()
      headband.x = 220
      headband.y = 0
      headband.rotation = Math.PI/8
      headband.append(simple, rotated, scaled, scaled2, scaled3)
      this.scene.append(
        headband,
        nested1,
        c1, c2,
        b1, b2, bc,
        hand
      )
    },

    hoverRed : function(t) {
      if (this.underCursor && this.root.target == this)
        this.fill = 'red'
      else
        this.fill = this.origFillStyle
    },

    makeRect : function() {
      var r = new Rectangle(20, 20, {fill: true, fillStyle: 'white'})
      r.origFillStyle = 'white'
      r.addFrameListener(this.hoverRed)
      return r
    },

    makeCircle : function(x, y) {
      var r = new Circle(50, {x: x, y: y})
      r.stroke = 'black'
      r.strokeWidth = 8
      r.origFillStyle = 'white'
      r.addFrameListener(this.hoverRed)
      return r
    }
  })
  Effects.add('Picking')



  SVGParserTest = CakeJS.Klass(Effect, {
    description : "SVG parser for simple documents. Converts SVG DOM to CAKE scenegraph.",

    file : "svgtext.svg",
    opacity : 1,
    fillOpacity : 1,
    fillBackground : true,
    compositeOperation : 'source-over',
    
    initialize : function(canvas, cc) {
      Effect.initialize.call(this, canvas, cc)
      this.canvas.fillStyle = [255, 255, 255, 1]
      this.svgScene = new CanvasNode()
      this.scene.appendChild(this.svgScene)
      this.fileInfo = new ElementNode(E('div'), {
        align: 'right', valign: 'bottom',
        x: 634, y: 480
      })
      this.fileInfo.content.style.width = '340px'
      this.fileInfo.content.style.textAlign = 'right'
      this.fileEmbed = E('div')
      this.fileInfo.content.appendChild(this.fileEmbed)
      this.fileLink = E('a')
      this.fileInfo.content.appendChild(E('div', this.fileLink))
      this.fileTitle = E('h4', {style: {
        margin: '0px', marginTop:'2px', color:'black'
      }})
      this.fileInfo.content.appendChild(this.fileTitle)
      this.fileDesc = E('p')
      this.fileInfo.content.appendChild(this.fileDesc)
      this.fileNotice = E('p')
      this.fileNotice.style.marginTop = '8px'
      this.fileNotice.style.fontSize = '80%'
      this.fileInfo.content.appendChild(this.fileNotice)
      this.scene.appendChild(this.fileInfo)
      this.setFile(this.file)
      this.scene.catchMouse = false
      this.svgScene.scale = 1
      this.svgScene.effect = this
      this.svgScene.addFrameListener(function (t, dt) {
        this.opacity = this.effect.opacity
        this.compositeOperation = this.effect.compositeOperation
        this.effect.canvas.fillStyle[3] = this.effect.fillOpacity
        this.effect.canvas.fill = (this.effect.fillBackground ?
                                   this.effect.canvas.fillStyle : false)
        if (this.root.mouseX != undefined) {
          if (this.scale < 2)
            this.scale += dt / 500
          if (this.scale > 2)
            this.scale = 2
          this.x += 0.5*(-(this.root.mouseX*this.scale-320) - this.x)
          this.y += 0.5*(-(this.root.mouseY*this.scale-240) - this.y)
        } else {
          if (this.scale > 1)
            this.scale -= dt / 200
          if (this.scale < 1)
            this.scale = 1
          this.x = -(320*this.scale-320)
          this.y = -(240*this.scale-240)
        }
      })
    },

    setFile : function(filename) {
      this.setupScreen(filename)
      var loading = this.loading
      var th = this
      var cc = document.defaultView.getComputedStyle(this.canvas.canvas,'').color
      SVGParser.load(filename, {
        width:  640,
        height: 480,
        fontSize: 12,
        currentColor: cc,
        onSuccess: function(svgNode, xhr) {
          if (th.file == filename) {
            th.fileTitle.innerHTML = (svgNode.title || '')
            th.fileDesc.innerHTML = (svgNode.description || '')
            if (svgNode.docWidth) {
              svgNode.scale = Math.min(1, 640 / svgNode.docWidth, 480 / svgNode.docHeight)
              svgNode.x = (640 - svgNode.docWidth*svgNode.scale) / 2
              svgNode.y = (480 - svgNode.docHeight*svgNode.scale) / 2
            }
            th.svgScene.append(svgNode)
            if (xhr.status == 0 && filename.search(/^svg_emblems/) != -1) {
              th.fileEmbed.innerHTML = '<object ' +
                'type="image/svg+xml" width="48" height="48" data=' +
                filename.escape() +
                '></object>'
            } else {
              th.fileEmbed.innerHTML = ''
            }
          }
          loading.removeSelf()
        },
        onFailure: function(xhr, e) {
          loading.content.innerHTML = ''
          if (e) {
            E.append(loading.content, E('h3', 'Error', {style:{color:'black'}}),
              e.toString())
            console.log(e)
          } else if (xhr.responseXML) {
            E.append(loading.content, E('h3', 'Error: '+xhr.status,
              {style:{color:'black'}}),
              xhr.responseXML)
          } else {
            E.append(loading.content, E('h3', 'Error: '+xhr.status,
              {style:{color:'black'}}),
              xhr.responseText)
          }
        }
      })
    },
  
    setupScreen : function(filename) {
      this.file = filename
      this.fileLink.innerHTML = ''
      this.fileLink.appendChild(T(filename))
      this.fileLink.href = filename
      this.fileTitle.innerHTML = this.fileDesc.innerHTML = ''
      if (filename.search(/^svg_examples/) != -1) {
        this.fileNotice.innerHTML = "Image from the <a href=\"http://www.w3.org/TR/SVG11/\">SVG 1.1 Specification</a>.<br>Copyright © 14 January 2003 <a href=\"http://www.w3.org/\">World Wide Web Consortium</a>,<br>(<a href=\"http://www.lcs.mit.edu/\">Massachusetts Institute of Technology</a>, <a href=\"http://www.inria.fr/\">Institut National de Recherche en Informatique et en Automatique</a>, <a href=\"http://www.keio.ac.jp/\">Keio University</a>).<br>All Rights Reserved.<br>http://www.w3.org/Consortium/Legal/"
      } else if (filename.search(/^svg_11_full/) != -1) {
        this.fileNotice.innerHTML = "<a href="+
        filename.replace(/svg\/([a-z0-9-_]+)\.svg/i, 'png/full-$1.png').escape()+
        ">Reference PNG</a><br><br>Image from the <a href=\"http://www.w3.org/Graphics/SVG/Test/\">SVG 1.1 Test Suite</a>.<br>Copyright © 13 December 2006 <a href=\"http://www.w3.org/\">World Wide Web Consortium</a>,<br>(<a href=\"http://www.lcs.mit.edu/\">Massachusetts Institute of Technology</a>, <a href=\"http://www.inria.fr/\">Institut National de Recherche en Informatique et en Automatique</a>, <a href=\"http://www.keio.ac.jp/\">Keio University</a>).<br>All Rights Reserved.<br>http://www.w3.org/Consortium/Legal/"
      } else {
        this.fileNotice.innerHTML = ''
      }
      this.svgScene.removeAllChildren()
      var loading = new ElementNode(E('div',
        'Loading '+filename+', please wait...'))
      loading.content.style.color = 'black'
      loading.align = 'center'
      loading.valign = 'center'
      loading.x = 320
      loading.y = 240
      loading.noAlpha = true
      if (this.loading) this.loading.removeSelf()
      this.svgScene.append(loading)
      this.loading = loading
    },
    
    controls : [
      ['compositeOperation', ['source-over', 'lighter', 'xor']],
      ['opacity', '0.0..1.0'],
      ['fillOpacity', '0.0..1.0'],
      'fillBackground',
      ['file',
        [
          '---',
          'svgtext.svg', 'cakenu.svg',
          'tiger.svg', 'lion.svg', 'butterfly.svg',
          'gearflowers.svg',
          'svg_examples/struct-image-01-t.svg',
          'svg_examples/struct-image-04-t.svg',
          'svg_examples/anim01.svg',
          'svg_examples/animMotion01.svg'
        ], {title: 'Some famous and less famous SVGs'}
      ],
      ['file',
        [
          '---',
          'svg_emblems/emblem-default.svg',
          'svg_emblems/emblem-documents.svg',
          'svg_emblems/emblem-downloads.svg',
          'svg_emblems/emblem-favorite.svg',
          'svg_emblems/emblem-generic.svg',
          'svg_emblems/emblem-important.svg',
          'svg_emblems/emblem-mail.svg',
          'svg_emblems/emblem-new.svg',
          'svg_emblems/emblem-package.svg',
          'svg_emblems/emblem-photos.svg',
          'svg_emblems/emblem-readonly.svg',
          'svg_emblems/emblem-shared.svg',
          'svg_emblems/emblem-symbolic-link.svg',
          'svg_emblems/emblem-system.svg',
          'svg_emblems/emblem-unreadable.svg',
          'svg_emblems/emblem-urgent.svg',
          'svg_emblems/emblem-web.svg'
        ], {title: 'Gnome icon theme emblems<br>(no blur filter, package shadow fails, web has bad images)'}
      ],
      ['file',
        [
          '---',
          'svg_examples/fillrule-nonzero.svg',
          'svg_examples/fillrule-evenodd.svg',
          'svg_examples/linecap.svg',
          'svg_examples/linejoin.svg',
          'svg_examples/marker.svg',
          'svg_examples/inheritance.svg'
        ], {title: 'SVG 1.1: 11 Painting: Filling, Stroking and Marker Symbols<br>(Fill rules fail)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/extend-namespace-01-f.svg',
          'svg_11_full/svg/metadata-example-01-b.svg',
          'svg_11_full/svg/types-basicDOM-01-b.svg'
        ], {title: 'Warning, the following SVG 1.1 test suite trigger many nasty bugs, and you may need to reload the page to restore the canvas to a working state.<br>(Fail: extend-namespace-01, types-basicDOM-01)' }
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/animate-elem-02-t.svg',
          'svg_11_full/svg/animate-elem-03-t.svg',
          'svg_11_full/svg/animate-elem-04-t.svg',
          'svg_11_full/svg/animate-elem-05-t.svg',
          'svg_11_full/svg/animate-elem-06-t.svg',
          'svg_11_full/svg/animate-elem-07-t.svg',
          'svg_11_full/svg/animate-elem-08-t.svg',
          'svg_11_full/svg/animate-elem-09-t.svg',
          'svg_11_full/svg/animate-elem-10-t.svg',
          'svg_11_full/svg/animate-elem-11-t.svg',
          'svg_11_full/svg/animate-elem-12-t.svg',
          'svg_11_full/svg/animate-elem-13-t.svg',
          'svg_11_full/svg/animate-elem-14-t.svg',
          'svg_11_full/svg/animate-elem-15-t.svg',
          'svg_11_full/svg/animate-elem-17-t.svg',
          'svg_11_full/svg/animate-elem-19-t.svg',
          'svg_11_full/svg/animate-elem-20-t.svg',
          'svg_11_full/svg/animate-elem-21-t.svg',
          'svg_11_full/svg/animate-elem-22-b.svg',
          'svg_11_full/svg/animate-elem-23-t.svg',
          'svg_11_full/svg/animate-elem-24-t.svg',
          'svg_11_full/svg/animate-elem-25-t.svg',
          'svg_11_full/svg/animate-elem-26-t.svg',
          'svg_11_full/svg/animate-elem-27-t.svg',
          'svg_11_full/svg/animate-elem-28-t.svg',
          'svg_11_full/svg/animate-elem-29-b.svg',
          'svg_11_full/svg/animate-elem-30-t.svg',
          'svg_11_full/svg/animate-elem-31-t.svg',
          'svg_11_full/svg/animate-elem-32-t.svg',
          'svg_11_full/svg/animate-elem-33-t.svg',
          'svg_11_full/svg/animate-elem-34-t.svg',
          'svg_11_full/svg/animate-elem-36-t.svg',
          'svg_11_full/svg/animate-elem-37-t.svg',
          'svg_11_full/svg/animate-elem-39-t.svg',
          'svg_11_full/svg/animate-elem-40-t.svg',
          'svg_11_full/svg/animate-elem-41-t.svg',
          'svg_11_full/svg/animate-elem-44-t.svg',
          'svg_11_full/svg/animate-elem-46-t.svg',
          'svg_11_full/svg/animate-elem-52-t.svg',
          'svg_11_full/svg/animate-elem-60-t.svg',
          'svg_11_full/svg/animate-elem-61-t.svg',
          'svg_11_full/svg/animate-elem-62-t.svg',
          'svg_11_full/svg/animate-elem-63-t.svg',
          'svg_11_full/svg/animate-elem-64-t.svg',
          'svg_11_full/svg/animate-elem-65-t.svg',
          'svg_11_full/svg/animate-elem-66-t.svg',
          'svg_11_full/svg/animate-elem-67-t.svg',
          'svg_11_full/svg/animate-elem-68-t.svg',
          'svg_11_full/svg/animate-elem-69-t.svg',
          'svg_11_full/svg/animate-elem-70-t.svg',
          'svg_11_full/svg/animate-elem-77-t.svg',
          'svg_11_full/svg/animate-elem-78-t.svg',
          'svg_11_full/svg/animate-elem-80-t.svg',
          'svg_11_full/svg/animate-elem-81-t.svg',
          'svg_11_full/svg/animate-elem-82-t.svg',
          'svg_11_full/svg/animate-elem-83-t.svg',
          'svg_11_full/svg/animate-elem-84-t.svg',
          'svg_11_full/svg/animate-elem-85-t.svg'
        ], {title: 'SVG 1.1 Full: Animation<br>(Fail: 02, 03, 12, 14, everything onwards)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/paths-data-01-t.svg',
          'svg_11_full/svg/paths-data-02-t.svg',
          'svg_11_full/svg/paths-data-03-f.svg',
          'svg_11_full/svg/paths-data-04-t.svg',
          'svg_11_full/svg/paths-data-05-t.svg',
          'svg_11_full/svg/paths-data-06-t.svg',
          'svg_11_full/svg/paths-data-07-t.svg',
          'svg_11_full/svg/paths-data-08-t.svg',
          'svg_11_full/svg/paths-data-09-t.svg',
          'svg_11_full/svg/paths-data-10-t.svg',
          'svg_11_full/svg/paths-data-12-t.svg',
          'svg_11_full/svg/paths-data-13-t.svg',
          'svg_11_full/svg/paths-data-14-t.svg',
          'svg_11_full/svg/paths-data-15-t.svg'
        ], {title: 'SVG 1.1 Full: Paths<br>(Fail: 03, 04, 05, 08, 09, 14)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/shapes-circle-01-t.svg',
          'svg_11_full/svg/shapes-circle-02-t.svg',
          'svg_11_full/svg/shapes-ellipse-01-t.svg',
          'svg_11_full/svg/shapes-ellipse-02-t.svg',
          'svg_11_full/svg/shapes-intro-01-t.svg',
          'svg_11_full/svg/shapes-line-01-t.svg',
          'svg_11_full/svg/shapes-polygon-01-t.svg',
          'svg_11_full/svg/shapes-polyline-01-t.svg',
          'svg_11_full/svg/shapes-rect-01-t.svg',
          'svg_11_full/svg/shapes-rect-02-t.svg'
        ], {title: 'SVG 1.1 Full: Shapes<br>(All work)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/masking-intro-01-f.svg',
          'svg_11_full/svg/masking-mask-01-b.svg',
          'svg_11_full/svg/masking-opacity-01-b.svg',
          'svg_11_full/svg/masking-path-01-b.svg',
          'svg_11_full/svg/masking-path-02-b.svg',
          'svg_11_full/svg/masking-path-03-b.svg',
          'svg_11_full/svg/masking-path-04-b.svg',
          'svg_11_full/svg/masking-path-05-f.svg'
        ], {title: 'SVG 1.1 Full: Masking<br>(All fail, path-01 works except for text)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/painting-fill-01-t.svg',
          'svg_11_full/svg/painting-fill-02-t.svg',
          'svg_11_full/svg/painting-fill-03-t.svg',
          'svg_11_full/svg/painting-fill-04-t.svg',
          'svg_11_full/svg/painting-fill-05-b.svg',
          'svg_11_full/svg/painting-marker-01-f.svg',
          'svg_11_full/svg/painting-marker-02-f.svg',
          'svg_11_full/svg/painting-marker-03-f.svg',
          'svg_11_full/svg/painting-render-01-b.svg',
          'svg_11_full/svg/painting-stroke-01-t.svg',
          'svg_11_full/svg/painting-stroke-02-t.svg',
          'svg_11_full/svg/painting-stroke-03-t.svg',
          'svg_11_full/svg/painting-stroke-04-t.svg',
          'svg_11_full/svg/painting-stroke-07-t.svg'
        ], {title: 'SVG 1.1 Full: Painting<br>(Fail: fill-03, marker-03, render-01 (catastrophic), stroke-04)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/coords-coord-01-t.svg',
          'svg_11_full/svg/coords-coord-02-t.svg',
          'svg_11_full/svg/coords-trans-01-b.svg',
          'svg_11_full/svg/coords-trans-02-t.svg',
          'svg_11_full/svg/coords-trans-03-t.svg',
          'svg_11_full/svg/coords-trans-04-t.svg',
          'svg_11_full/svg/coords-trans-05-t.svg',
          'svg_11_full/svg/coords-trans-06-t.svg',
          'svg_11_full/svg/coords-units-01-b.svg',
          'svg_11_full/svg/coords-units-02-b.svg',
          'svg_11_full/svg/coords-units-03-b.svg',
          'svg_11_full/svg/coords-viewattr-01-b.svg',
          'svg_11_full/svg/coords-viewattr-02-b.svg',
          'svg_11_full/svg/coords-viewattr-03-b.svg'
        ], {title: 'SVG 1.1 Full: Coords<br>(Fail: units-01 (catastrophic), viewattr-02, viewattr-03)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/color-prof-01-f.svg',
          'svg_11_full/svg/color-prop-01-b.svg',
          'svg_11_full/svg/color-prop-02-f.svg',
          'svg_11_full/svg/color-prop-03-t.svg'
        ], {title: 'SVG 1.1 Full: Colors<br>(Fail: prof-01)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/filters-blend-01-b.svg',
          'svg_11_full/svg/filters-color-01-b.svg',
          'svg_11_full/svg/filters-composite-02-b.svg',
          'svg_11_full/svg/filters-comptran-01-b.svg',
          'svg_11_full/svg/filters-conv-01-f.svg',
          'svg_11_full/svg/filters-diffuse-01-f.svg',
          'svg_11_full/svg/filters-displace-01-f.svg',
          'svg_11_full/svg/filters-example-01-b.svg',
          'svg_11_full/svg/filters-felem-01-b.svg',
          'svg_11_full/svg/filters-gauss-01-b.svg',
          'svg_11_full/svg/filters-image-01-b.svg',
          'svg_11_full/svg/filters-light-01-f.svg',
          'svg_11_full/svg/filters-morph-01-f.svg',
          'svg_11_full/svg/filters-offset-01-b.svg',
          'svg_11_full/svg/filters-specular-01-f.svg',
          'svg_11_full/svg/filters-tile-01-b.svg',
          'svg_11_full/svg/filters-turb-01-f.svg'
        ], {title: 'SVG 1.1 Full: Filters<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/linking-a-01-b.svg',
          'svg_11_full/svg/linking-a-02-b.svg',
          'svg_11_full/svg/linking-a-03-b.svg',
          'svg_11_full/svg/linking-a-04-t.svg',
          'svg_11_full/svg/linking-a-05-t.svg',
          'svg_11_full/svg/linking-a-07-t.svg',
          'svg_11_full/svg/linking-uri-01-b.svg',
          'svg_11_full/svg/linking-uri-02-b.svg',
          'svg_11_full/svg/linking-uri-03-t.svg'
        ], {title: 'SVG 1.1 Full: Linking<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/interact-cursor-01-f.svg',
          'svg_11_full/svg/interact-dom-01-b.svg',
          'svg_11_full/svg/interact-events-01-b.svg',
          'svg_11_full/svg/interact-order-01-b.svg',
          'svg_11_full/svg/interact-order-02-b.svg',
          'svg_11_full/svg/interact-order-03-b.svg',
          'svg_11_full/svg/interact-zoom-01-t.svg'
        ], {title: 'SVG 1.1 Full: Interact<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/pservers-grad-01-b.svg',
          'svg_11_full/svg/pservers-grad-02-b.svg',
          'svg_11_full/svg/pservers-grad-03-b.svg',
          'svg_11_full/svg/pservers-grad-04-b.svg',
          'svg_11_full/svg/pservers-grad-05-b.svg',
          'svg_11_full/svg/pservers-grad-06-b.svg',
          'svg_11_full/svg/pservers-grad-07-b.svg',
          'svg_11_full/svg/pservers-grad-08-b.svg',
          'svg_11_full/svg/pservers-grad-09-b.svg',
          'svg_11_full/svg/pservers-grad-10-b.svg',
          'svg_11_full/svg/pservers-grad-11-b.svg',
          'svg_11_full/svg/pservers-grad-12-b.svg',
          'svg_11_full/svg/pservers-grad-13-b.svg',
          'svg_11_full/svg/pservers-grad-14-b.svg',
          'svg_11_full/svg/pservers-grad-15-b.svg',
          'svg_11_full/svg/pservers-grad-16-b.svg',
          'svg_11_full/svg/pservers-grad-17-b.svg',
          'svg_11_full/svg/pservers-grad-18-b.svg',
          'svg_11_full/svg/pservers-grad-19-b.svg',
          'svg_11_full/svg/pservers-pattern-01-b.svg'
        ], {title: 'SVG 1.1 Full: Pservers<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/render-elems-01-t.svg',
          'svg_11_full/svg/render-elems-02-t.svg',
          'svg_11_full/svg/render-elems-03-t.svg',
          'svg_11_full/svg/render-elems-06-t.svg',
          'svg_11_full/svg/render-elems-07-t.svg',
          'svg_11_full/svg/render-elems-08-t.svg',
          'svg_11_full/svg/render-groups-01-b.svg',
          'svg_11_full/svg/render-groups-03-t.svg'
        ], {title: 'SVG 1.1 Full: Render<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/script-handle-01-b.svg',
          'svg_11_full/svg/script-handle-02-b.svg',
          'svg_11_full/svg/script-handle-03-b.svg',
          'svg_11_full/svg/script-handle-04-b.svg'
        ], {title: 'SVG 1.1 Full: Script<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/struct-cond-01-t.svg',
          'svg_11_full/svg/struct-cond-02-t.svg',
          'svg_11_full/svg/struct-cond-03-t.svg',
          'svg_11_full/svg/struct-defs-01-t.svg',
          'svg_11_full/svg/struct-dom-01-b.svg',
          'svg_11_full/svg/struct-dom-02-b.svg',
          'svg_11_full/svg/struct-dom-03-b.svg',
          'svg_11_full/svg/struct-dom-04-b.svg',
          'svg_11_full/svg/struct-dom-05-b.svg',
          'svg_11_full/svg/struct-dom-06-b.svg',
          'svg_11_full/svg/struct-frag-01-t.svg',
          'svg_11_full/svg/struct-frag-02-t.svg',
          'svg_11_full/svg/struct-frag-03-t.svg',
          'svg_11_full/svg/struct-frag-04-t.svg',
          'svg_11_full/svg/struct-frag-05-t.svg',
          'svg_11_full/svg/struct-frag-06-t.svg',
          'svg_11_full/svg/struct-group-01-t.svg',
          'svg_11_full/svg/struct-group-02-b.svg',
          'svg_11_full/svg/struct-group-03-t.svg',
          'svg_11_full/svg/struct-image-01-t.svg',
          'svg_11_full/svg/struct-image-02-b.svg',
          'svg_11_full/svg/struct-image-03-t.svg',
          'svg_11_full/svg/struct-image-04-t.svg',
          'svg_11_full/svg/struct-image-05-b.svg',
          'svg_11_full/svg/struct-image-06-t.svg',
          'svg_11_full/svg/struct-image-07-t.svg',
          'svg_11_full/svg/struct-image-08-t.svg',
          'svg_11_full/svg/struct-image-09-t.svg',
          'svg_11_full/svg/struct-image-10-t.svg',
          'svg_11_full/svg/struct-symbol-01-b.svg',
          'svg_11_full/svg/struct-use-01-t.svg',
          'svg_11_full/svg/struct-use-03-t.svg',
          'svg_11_full/svg/struct-use-05-b.svg'
        ], {title: 'SVG 1.1 Full: Struct<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/styling-css-01-b.svg',
          'svg_11_full/svg/styling-css-02-b.svg',
          'svg_11_full/svg/styling-css-03-b.svg',
          'svg_11_full/svg/styling-css-04-f.svg',
          'svg_11_full/svg/styling-css-05-b.svg',
          'svg_11_full/svg/styling-css-06-b.svg',
          'svg_11_full/svg/styling-inherit-01-b.svg',
          'svg_11_full/svg/styling-pres-01-t.svg'
        ], {title: 'SVG 1.1 Full: Styling<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/fonts-desc-02-t.svg',
          'svg_11_full/svg/fonts-elem-01-t.svg',
          'svg_11_full/svg/fonts-elem-02-t.svg',
          'svg_11_full/svg/fonts-elem-03-b.svg',
          'svg_11_full/svg/fonts-elem-04-b.svg',
          'svg_11_full/svg/fonts-elem-05-t.svg',
          'svg_11_full/svg/fonts-elem-06-t.svg',
          'svg_11_full/svg/fonts-elem-07-b.svg',
          'svg_11_full/svg/fonts-glyph-02-t.svg',
          'svg_11_full/svg/fonts-glyph-03-t.svg',
          'svg_11_full/svg/fonts-glyph-04-t.svg',
          'svg_11_full/svg/fonts-kern-01-t.svg'
        ], {title: 'SVG 1.1 Full: Fonts<br>(All fail, Untested)'}
      ],
      ['file',
        [
          '---',
          'svg_11_full/svg/text-align-01-b.svg',
          'svg_11_full/svg/text-align-02-b.svg',
          'svg_11_full/svg/text-align-03-b.svg',
          'svg_11_full/svg/text-align-04-b.svg',
          'svg_11_full/svg/text-align-05-b.svg',
          'svg_11_full/svg/text-align-06-b.svg',
          'svg_11_full/svg/text-align-08-b.svg',
          'svg_11_full/svg/text-altglyph-01-b.svg',
          'svg_11_full/svg/text-deco-01-b.svg',
          'svg_11_full/svg/text-fonts-01-t.svg',
          'svg_11_full/svg/text-fonts-02-t.svg',
          'svg_11_full/svg/text-fonts-03-t.svg',
          'svg_11_full/svg/text-intro-01-t.svg',
          'svg_11_full/svg/text-intro-02-b.svg',
          'svg_11_full/svg/text-intro-03-b.svg',
          'svg_11_full/svg/text-intro-04-t.svg',
          'svg_11_full/svg/text-intro-05-t.svg',
          'svg_11_full/svg/text-path-01-b.svg',
          'svg_11_full/svg/text-spacing-01-b.svg',
          'svg_11_full/svg/text-text-01-b.svg',
          'svg_11_full/svg/text-text-03-b.svg',
          'svg_11_full/svg/text-text-04-t.svg',
          'svg_11_full/svg/text-text-05-t.svg',
          'svg_11_full/svg/text-text-06-t.svg',
          'svg_11_full/svg/text-text-07-t.svg',
          'svg_11_full/svg/text-text-08-b.svg',
          'svg_11_full/svg/text-tref-01-b.svg',
          'svg_11_full/svg/text-tselect-01-b.svg',
          'svg_11_full/svg/text-tselect-02-f.svg',
          'svg_11_full/svg/text-tspan-01-b.svg',
          'svg_11_full/svg/text-ws-01-t.svg',
          'svg_11_full/svg/text-ws-02-t.svg'
        ], {title: 'SVG 1.1 Full: Text<br>(All fail, Untested)'}
      ]
    ]
  })
  Effects.add('SVGParserTest')


  RecordingTest = CakeJS.Klass(Effect, {
    description : "Records canvas drawing commands and plays them back on a different canvas. See <a href=\"canvasmage.html\">CanvasMage</a>",

    initialize : function(canvas, cc) {
      Effect.initialize.call(this, canvas, cc)
      var circles = new Circles(canvas,cc)
      canvas.recording = true
      var smallCanvas = E.canvas(320, 240)
      var doc = "This shows up alright since it's really a DOM node."
      var en = new ElementNode(smallCanvas)
      en.x = 160
      en.y = 120
      var ctx = CanvasSupport.getContext(smallCanvas, '2d')
      this.scene.append(en)
      this.scene.append(circles.scene)
      var frames = []
      var i = 0
      var firstFrame = true
      var dir = 1
      var th = this
      this.scene.addFrameListener(function() {
        if (frames.length < 50) {
          var rc = canvas.getRecordingContext()
          var rec = rc.getRecording()
          if (firstFrame) // skip first frame
            firstFrame = false
          else
            frames.push(rec)
          rc.clear()
        } else if (circles.scene.parent) {
          circles.scene.removeSelf()
          canvas.recording = false
          canvas.clear = false
          var rec = frames[0]
        } else {
          i += dir
          if (i < 0 || i >= frames.length) {
            dir = -dir
            i += 2 * dir
          }
          var rec = frames[i]
        }
        th.playRecording(ctx, rec)
      })
    },

    playRecording : function(ctx, recording) {
      ctx.save()
        ctx.scale(0.5, 0.5)
        RecordingContext.play(ctx, recording)
      ctx.restore()
    }
  })
  Effects.add('RecordingTest')

  SkewTest = CakeJS.Klass(Effect, {
    description : "Skew test.",
  
    initialize : function(canvas, cc) {
      Effect.initialize.apply(this, arguments)
      var ct = new ClipTest(canvas, cc)
      this.scene.append(ct.scene)
      this.scene.addFrameListener(function(t) {
        ct.scene.childNodes[0].skewX = (Math.PI/4) * Math.sin(t / 1000)
        ct.scene.childNodes[1].skewY = (Math.PI/3) * -Math.sin(t / 1000)
      })
    }
  })
  Effects.add('SkewTest')

  CustomDrawing = CakeJS.Klass(Effect, {
    description : "Custom drawing using the canvas context.",

    initialize : function(canvas, cc) {
      Effect.initialize.apply(this, arguments)
      this.canvas.fill = '#33363C'
      this.scene.counter = 0
      this.scene.overCounter = 0
      this.scene.draw = function(ctx) {
        var v = 1
        if (this.root.mouseX != undefined) {
          var dx = (this.root.mouseX - 320)
          var dy = (this.root.mouseY - 240)
          if (dx == 0 && dy == 0) {
            this.overCounter++
          } else {
            this.overCounter = 0
          }
          v = Math.max(1, 100 * 1 / (Math.sqrt(dx*dx + dy*dy)+1))
        }
        this.counter += v
        var t = this.counter * 0.03
        if (this.root.mouseX != undefined) {
          var r = 30
          ctx.save()
          ctx.translate(this.root.mouseX, this.root.mouseY)
          ctx.strokeStyle = 'cyan'
          var a = 1 / v + this.overCounter * 0.02
          if (a > 1) a = 1
          ctx.globalAlpha = a
          ctx.strokeWidth = Math.max(2,v)
          for (var i=0; i<Math.PI*2; i+=Math.PI/2.5) {
            ctx.beginPath()
            ctx.arc(0, 0, r, -t+i, -t+i+v*0.03, false)
            ctx.stroke()
          }
          ctx.restore()
        }
        var r = 100
        ctx.save()
          a = 1 / v + this.overCounter * 0.02
          if (a > 1) a = 1
          ctx.globalAlpha = a
          ctx.translate(320, 240)
          ctx.strokeStyle = 'cyan'
          ctx.strokeWidth = 10
          for (var i=0; i<Math.PI*2; i+=Math.PI/2.5) {
            ctx.beginPath()
            ctx.arc(0, 0, r, t+i, t+i+v*0.03, false)
            ctx.stroke()
          }
        ctx.restore()
      }
    }
  })
  Effects.add('CustomDrawing')


  Paint = CakeJS.Klass(Effect, {
    description : "Draw draw draw.",
    controls : ['clear'],

    initialize : function() {
      Effect.initialize.apply(this, arguments)
//       this.canvas.showFpsHistogram = false
      this.canvas.fill = 'white'
      this.canvas.frameDuration = 10
      var brush = new Polygon([], {closePath: false})
      brush.strokeWidth = 1
      brush.stroke = 'black'
      this.needClear = true
      this.canvas.addEventListener('mousedown', function(ev) {
        ev.preventDefault() }, false)
      this.scene.addFrameListener(function() {
        if (this.effect.needClear) {
          this.root.clear = true
          this.effect.needClear = false
        } else {
          this.root.clear = false
        }
      })
      brush.addFrameListener(function() {
        var mouseMoves = this.root.mouseEvents.allWith(2).take(0,1).flatten()
        // FIXME assert contiguous strokes!
        if (mouseMoves.length > 0 || this.root.mouseDown) {
          var segs = this.segments
          if (segs.length > 0)
            this.segments = segs.slice(-2).concat(mouseMoves)
          else
            this.segments = mouseMoves
          if (this.segments.length == 2) {
            this.segments = this.segments.concat(this.segments)
          }
          this.visible = (this.segments.length > 0)
        } else {
          if (this.segments.length > 0)
            this.segments = []
          this.strokeStarted = false
          this.visible = false
        }
      })
      this.scene.append(brush)
    },

    clear : function() {
      this.needClear = true
    }
  })
  Effects.add('Paint')


  SummoningCircle = CakeJS.Klass(Effect, {
    description : "An occult tool for summoning daemons.",
    controls : ['spirals'],
    spirals: false,
    
    initialize: function() {
      Effect.initialize.apply(this, arguments)
      this.canvas.fill = 'rgba(0,0,50,0.2)'
      this.canvas.addEventListener('click', function() {
        if (this.effect.spirals)
          this.effect.createSpiral(this.root.mouseX, this.root.mouseY)
        else
          this.effect.createSummoningCircle(this.root.mouseX, this.root.mouseY)
      }.bind(this.scene), false)
    },

    createSpiral : function(x,y) {
      var sp = new Spiral(0, {x: x, y: y, stroke:'cyan'})
      sp.startRadius = 1
      if (this.spiro) {
        sp.radiusFunction = function(a) {
          return 100*Math.sin(a*0.3)
        }
      } else {
        sp.radiusFunction = function(a) {
          return Math.pow(1.1, a)
        }
      }
      sp.animateTo('endAngle', Math.PI*22, 2000, 'square')
      sp.after(2000, function() {
        this.animate('opacity', 1, 0, 1000, 'sine')
      })
      sp.after(3000, sp.removeSelf)
      this.scene.append(sp)
    },

    createSummoningCircle : function(x, y) {
      var c = new Circle(1, {x: x, y: y, stroke:'cyan'})
      var p = new Polygon([])
      p.stroke = true
      for (var i=0; i<6; i++) {
        p.segments.push(Math.cos(i*Math.PI/3))
        p.segments.push(Math.sin(i*Math.PI/3))
      }
      var p2 = p.clone()
      p2.scale = 0.8
      p.append(p2)
      p.strokeWidth = 0.02
      p.append(new Circle(0.2, {x: 1, y: 0}))
      p.append(new Circle(0.2, {x: Math.cos(2*Math.PI/3), y: Math.sin(2*Math.PI/3)}))
      p.append(new Circle(0.2, {x: Math.cos(-2*Math.PI/3), y: Math.sin(-2*Math.PI/3)}))
      p.append(new Circle(0.25, {x: 1, y: 0}))
      p.append(new Circle(0.25, {x: Math.cos(2*Math.PI/3), y: Math.sin(2*Math.PI/3)}))
      p.append(new Circle(0.25, {x: Math.cos(-2*Math.PI/3), y: Math.sin(-2*Math.PI/3)}))
      p.append(new Circle(0.83, {strokeWidth: 0.06}))
      p2.append(new Line(0,0,p.segments[0],p.segments[1]))
      p2.append(new Line(0,0,p.segments[2],p.segments[3]))
      p2.append(new Line(0,0,p.segments[4],p.segments[5]))
      p2.append(new Line(0,0,p.segments[6],p.segments[7]))
      p2.append(new Line(0,0,p.segments[8],p.segments[9]))
      p2.append(new Line(0,0,p.segments[10],p.segments[11]))
      p2.animate("rotation", 0, Math.PI, 500, "sine")
      p.animate("scale", 1, 77, 500, "sproing")
      p.animate("rotation", 0, -0.5*Math.PI, 500, "sine")
      c.append(p)
      c.animateTo('radius', 80, 500, 'sproing')
      c.animate('strokeWidth', 1, 5, 500, 'sproing')
      c.after(500, function() {
        this.animate('opacity', 1, 0, 1000, 'sine')
        this.after(500, function(){
          this.animateToFactor("scale", 1.5, 500)
        })
        this.after(1000, this.removeSelf)
      })
      c.scale = [1.2,0.5]
      c.scale = 1
      this.scene.append(c)
    }
  })
  Effects.add('SummoningCircle')


  Grapher = CakeJS.Klass(Effect, {
    description : "Create animated graphs.",

    initialize : function() {
      Effect.initialize.apply(this, arguments)
    }
  })


  CakeDraw = CakeJS.Klass(Effect, {
    description : "A simple vector drawing program.",

    initialize : function() {
      Effect.initialize.apply(this, arguments)

      /* bezier paths
      mouse down to start path
      mouse up to set second control point
      mouse down to create fourth control point
      mouse up to set third control point (mirrored over fourth)
      mouse down to create next seg fourth cp and set second cp (prev mouseup)
      mouse up to set third cp (mirrored over fourth)
      ...
      click on first cp handle to close path
      press esc to end path
      */

      /* gradients
      radial gradient control points: r1, center1, r2, center1
      linear gradient control points: p1, p2
      gradient color stops
      gradient curve
      */

      /* colors
      color picker with SV in big square, H in slider [ ]|
      */

      /* transforms
      move path, rotate path, scale path
      */

    }
  })
//   Effects.add('CakeDraw')


  EditableCurve = CakeJS.Klass(Effect, {
    description: 'Rectangle following an editable Bézier curve.',
    controls : ['constantSpeed'],
    constantSpeed : false,
    
    initialize : function() {
      Effect.initialize.apply(this, arguments)
      this.canvas.fill = 'rgba(0,0,20,0.15)'
      this.scene.compositeOperation = 'lighter'
      var rect = new Rectangle(10, 40, {centered:true})
      var g = new Gradient({
        type : 'radial',
        endRadius : 20,
        colorStops : [
          [ 0.0, "rgba(40,195,90,1)" ],
          [ 0.2, "rgba(5,10,80,0.8)" ],
          [ 1, "rgba(100,0,40,0)" ]
        ]
      })
      rect.fill = g
      var a = [50,50]
      var b = [300, 200]
      var c = [100, 300]
      var d = [480, 400]
      var cps = [a,b,c,d]
      rect.effect = this
      rect.addFrameListener(function(t,dt) {
        var rt = (t / 5000)%1
        if (this.effect.constantSpeed) {
          var p = Curves.cubicLengthPointAngle(cps[0],cps[1],cps[2],cps[3], rt)
          var point = p.point
          var angle = p.angle
        } else {
          var point = Curves.cubicPoint(cps[0],cps[1],cps[2],cps[3], rt)
          var angle = Curves.cubicAngle(cps[0],cps[1],cps[2],cps[3], rt)
        }
        this.x = point[0]
        this.y = point[1]
        this.rotation = angle
      })
      var s = this.scene
      var i = 0
      var focused = false
      cps.forEach(function(p) {
        var cp = new Rectangle(
          10,10, {centered:true, fill: 'rgba(40,30,0,0.3)', x:p[0], y:p[1], zIndex:1}
        )
        cp.index = i
        cp.addEventListener('mousedown', function(ev) {
          if (ev.canvasTarget != this) return
          if (focused)
            focused.fill = 'rgba(40,30,0,0.3)'
          focused = this
          this.fill = 'rgba(40,30,0,0.7)'
        }, false)
        s.append(cp)
        i++
      })
      var path = new Path([['moveTo', a], ['bezierCurveTo', [b,c,d].flatten()]], {stroke:'rgba(10,20,30,0.3)',zIndex:-1})
      var poly = new Polygon([a,b,c,d].flatten(), {closePath: false, stroke:'rgba(40,30,0,0.3)', zIndex: 0.5})
      this.canvas.addEventListener('mouseup', function() {
        if (focused)
          focused.fill = 'rgba(40,30,0,0.3)'
        focused = false
      }, false)
      this.canvas.addEventListener('mousemove', function() {
        if (focused && this.root.mouseX != undefined) {
          cps[focused.index] = [this.root.mouseX, this.root.mouseY]
          poly.segments[focused.index*2] = this.root.mouseX
          poly.segments[focused.index*2+1] = this.root.mouseY
          if (focused.index == 0) {
            path.segments[0][1] = cps[focused.index]
          } else {
            path.segments[1][1][(focused.index-1)*2] = this.root.mouseX
            path.segments[1][1][(focused.index-1)*2+1] = this.root.mouseY
          }
          focused.x = this.root.mouseX
          focused.y = this.root.mouseY
        }
      }, false)
      this.canvas.addEventListener('mousedown', function(ev) {
        ev.preventDefault() }, false)
      this.scene.append(rect,path, poly)
    }
  })
  Effects.add('EditableCurve')


  CatmullRom = CakeJS.Klass(Effect, {
    description : "Add points to the Catmull-Rom spline for it to follow. Shift-click a control point to delete it.",
    controls : ['loop'],
    loop : true,

    unfocusedColor : 'rgba(250,150,30,0.5)',
    focusedColor : 'rgba(250,150,60,0.8)',

    setLoop : function(l) {
      this.loop = this.spline.loop = this.rect.loop = l
      delete this.spline.compiled
      delete this.rect.compiled
    },
  
    initialize : function() {
      Effect.initialize.apply(this, arguments)
      var curve = [[320,50], [440,400], [150, 300], [490,300], [200,400]]
      this.curve = []
      this.spline = new CatmullRomSpline(this.curve,
        {stroke:'white',
         fill:this.unfocusedColor,
         zIndex : -1, loop : this.loop})
      var rect = this.rect = new CatmullRomSpline(this.curve, {
         fill:this.focusedColor,
         zIndex : 0, loop : this.loop,
         scale : 0.15
      })
      rect.effect = this
      rect.pickable = false
      rect.addFrameListener(function(t,dt) {
        var p = this.effect.spline.pointAngleAt((t/10000)%1)
        this.x = p.point[0]
        this.y = p.point[1]
        this.rotation = p.angle
      })
      for (var i=0; i<curve.length; i++)
        this.addControlPoint(curve[i][0], curve[i][1])
      this.scene.append(rect, this.spline)
      
      this.canvas.addEventListener('click', function(ev) {
        if (ev.shiftKey) return
        if (this.effect.moved)
          this.effect.moved = false
        else
          this.effect.addControlPoint(this.root.mouseX, this.root.mouseY)
      }.bind(this.scene), false)

      this.canvas.addEventListener('mouseup', function() {
        if (this.effect.focused)
          this.effect.focused.fill = this.effect.unfocusedColor
        this.effect.focused = false
      }.bind(this.scene), false)
      
      this.canvas.addEventListener('mousemove', function() {
        var focused = this.effect.focused
        var cps = this.effect.curve
        if (focused && focused.parent && this.root.mouseX != undefined) {
          cps[focused.index][0] = this.root.mouseX
          cps[focused.index][1] = this.root.mouseY
          focused.x = this.root.mouseX
          focused.y = this.root.mouseY
          focused.xElem.textContent = focused.x
          focused.yElem.textContent = focused.y
          delete this.effect.spline.compiled
          delete this.effect.rect.compiled
        }
      }.bind(this.scene), false)

      this.canvas.addEventListener('mousedown', function(ev) {
        ev.preventDefault()
        return false
      }, false)
    },

    addControlPoint : function(x,y) {
      var c = new Circle(10, {fill:this.unfocusedColor})
      c.x = x
      c.y = y
      c.index = this.curve.length
      c.effect = this
      c.xElem = T(x)
      c.yElem = T(y)
      var ce = E('div')
      E.append(ce, c.xElem, ', ', c.yElem)
      ce.style.color = 'white'
      c.append(new ElementNode(ce, {x:10,y:10}))
      c.addEventListener('mousedown', function() {
        if (this.effect.focused)
          this.effect.focused.fill = this.effect.unfocusedColor
        this.fill = this.effect.focusedColor
        this.effect.focused = this
        this.effect.moved = true
      }, false)
      c.addEventListener('click', function(ev) {
        if (ev.shiftKey && this.parent) {
          this.effect.focused = false
          this.effect.curve.splice(this.index, 1)
          this.removeSelf()
          var t = this
          this.effect.scene.childNodes.forEach(function(c) {
            if (t.index < c.index) c.index -= 1
          })
          this.effect.moved = false
          delete this.effect.spline.compiled
          delete this.effect.rect.compiled
          return false
        }
      }, false)
      this.curve.push([x,y])
      delete this.spline.compiled
      delete this.rect.compiled
      this.scene.append(c)
    }

  })
  Effects.add('CatmullRom')


  TransformWidgetProto = CakeJS.Klass(Effect, {
    description : 'Prototyping a transform widget. Needs original scale snap and shift-constraining.',
    
    unfocusedColor : 'rgba(250,150,30,0.5)',
    
    initialize : function() {
      Effect.initialize.apply(this, arguments)
      var curve = [[320,50], [440,400], [150, 300], [490,300], [200,400]]
      this.spline = new CatmullRomSpline(
        curve.map(function(xy){ return [xy[0]-320, xy[1]-240] }),
        {stroke:'white',
         fill:this.unfocusedColor,
         zIndex : -1, loop : true})
      var c = this.spline
      this.circle = c
      var tf = this.makeTransformWidget(c)
      tf.x = 320
      tf.y = 240
      this.scene.append(tf)
    },

    makeTransformWidget : function(obj) {
      var bb = obj.getBoundingBox()
      var w = new CanvasNode()
      var obj_container = new CanvasNode({zIndex:-1})
      var obj_c2 = new CanvasNode({zIndex:-1})
      obj_c2.appendChild(obj)
      obj_container.append(obj_c2)
      obj_container.transformList = []
      obj_container.rotation = [0, 0, 0]
      obj_c2.transformList = [
        ['translate', [0,0]],
        ['scale', [1,1]],
        ['translate', [0,0]]
      ]
      w.append(obj_container)

      var origin = new CanvasNode(
        {stroke:'white', compositeOperation:'xor', strokeWidth:1})
      var originHandle = new Circle(10, {
        zIndex : 2,
        strokeWidth: 2
      })
      origin.append(originHandle)
      origin.append(new Line(-4, 0, 4, 0))
      origin.append(new Line(0, -4, 0, 4))
      var rotwheel = new Circle(30, {
        zIndex: 1.5,
        strokeWidth: 1
      })
      var rotline = new Line(0,0,0,0,{visible: false})
      rotline.zIndex = 2
      var refline = new Line(0,0,0,0)
      refline.zIndex = 1
      rotline.append(refline)
      var oline = new Line(0,0,0,0,{strokeWidth:2})
      rotline.append(oline)
      origin.append(rotline, rotwheel)
      w.append(origin)
      var cr = new CanvasNode({
        stroke: 'white',
        strokeWidth: 1,
        compositeOperation : 'xor'
      })
      cr.append(new Line(-15, 0, 15, 0))
      cr.append(new Line(0, -15, 0, 15))
      obj_container.append(cr)
      originHandle.addEventListener('drag', function() {
        origin.x = this.root.mouseX - origin.parent.currentMatrix[4]
        origin.y = this.root.mouseY - origin.parent.currentMatrix[5]
        var dx = this.root.mouseX - cr.currentMatrix[4]
        var dy = this.root.mouseY - cr.currentMatrix[5]
        if ((dx*dx + dy*dy) < 49) {
          origin.x = cr.currentMatrix[4] - origin.parent.currentMatrix[4]
          origin.y = cr.currentMatrix[5] - origin.parent.currentMatrix[5]
        }
        obj_container.rotation[1] = origin.x
        obj_container.rotation[2] = origin.y
      }, false)
      originHandle.addEventListener('dragstart', function() {
        if (obj_container.rotation[0]) {
          obj_container.transformList.unshift(['rotate', obj_container.rotation])
          obj_container.rotation = [0,0,0]
        }
      }, false)
      rotwheel.addEventListener('dragstart', function() {
        var x = this.root.mouseX - origin.parent.currentMatrix[4]
        var y = this.root.mouseY - origin.parent.currentMatrix[5]
        var cx = origin.x
        var cy = origin.y
        this.originalRotation = obj_container.rotation[0]
        this.zeroRotation = obj_container.transformList.reduce(function(s,i){
          if (i[0] == 'rotate') s -= i[1][0]
          return s
        }, 0)
        this.rotationStartAngle = Curves.lineAngle([cx,cy], [x,y])
        rotline.visible = true
        refline.x2 = rotline.x2 = x-cx
        refline.y2 = rotline.y2 = y-cy
        var len = refline.getLength()
        refline.x2 *= (200 / len)
        refline.y2 *= (200 / len)
        oline.x2 = Math.cos(this.zeroRotation-this.originalRotation+this.rotationStartAngle) * 150
        oline.y2 = Math.sin(this.zeroRotation-this.originalRotation+this.rotationStartAngle) * 150
      }, false)
      rotwheel.addEventListener('drag', function() {
        var x = this.root.mouseX - origin.parent.currentMatrix[4]
        var y = this.root.mouseY - origin.parent.currentMatrix[5]
        var cx = origin.x
        var cy = origin.y
        rotline.x2 = x-cx
        rotline.y2 = y-cy
        var o = (-this.originalRotation+this.rotationStartAngle)
        var a = Curves.lineAngle([cx,cy], [x,y])
        var d = (a - this.rotationStartAngle)
        var od = Math.abs((a - (this.zeroRotation+o)) % (2*Math.PI))
        var rot = this.originalRotation + d
        var len = rotline.getLength()
        var snap = 5 / (len+1)
        if (od < snap || 2*Math.PI-od < snap) rot = this.zeroRotation
        else if (Math.abs(d) < snap) rot = this.originalRotation
        rotline.x2 = len * Math.cos(o+rot)
        rotline.y2 = len * Math.sin(o+rot)
        obj_container.rotation[0] = rot
      }, false)
      rotwheel.addEventListener('dragend', function() {
        rotline.visible = false
      }, false)
      var box = new Rectangle(bb[2], bb[3], {
        zIndex : 0,
        cx:bb[0], cy:bb[1],
        stroke:'white',
        strokeWidth: 1,
        compositeOperation : 'xor'
      })
      box.addEventListener('dragstart', function(ev) {
        if (ev.altKey) {
          ev.canvasTarget = rotwheel
          this.root.dragTarget = rotwheel
          rotwheel.handleEvent(ev)
        } else {
          this.dragX = this.root.mouseX
          this.dragY = this.root.mouseY
        }
      },false)
      box.addEventListener('drag', function() {
        var dx = this.root.mouseX - this.dragX
        var dy = this.root.mouseY - this.dragY
        this.dragX = this.root.mouseX
        this.dragY = this.root.mouseY
        w.x += dx
        w.y += dy
      },false)
      var cornerPoints = [
        [bb[0], bb[1]],
        [bb[0], bb[1]+bb[3]],
        [bb[0]+bb[2], bb[1]],
        [bb[0]+bb[2], bb[1]+bb[3]]
      ]
      cornerPoints.left = []
      cornerPoints.top = []
      cornerPoints.bottom = []
      cornerPoints.right = []
      for (var i=0; i<cornerPoints.length; i++) {
        var p = cornerPoints[i]
        var cp = new Circle(5, {
          x:p[0], y:p[1],
          zIndex: 1,
          stroke:'white',
          compositeOperation:'xor'
        })
        cp.addEventListener('drag', function(ev) {
          var im = CanvasSupport.tInvertMatrix(obj_container.currentMatrix)
          var xy = CanvasSupport.tMatrixMultiplyPoint(im, this.root.mouseX, this.root.mouseY)
          var x = xy[0] - box.x
          var y = xy[1] - box.y
          if (this.hside == 'left') {
            box.width -= x - box.cx
          } else {
            box.width = x - box.cx
          }
          if (this.vside == 'top') {
            box.height -= y - box.cy
          } else {
            box.height = y - box.cy
          }
          var scale = obj_c2.transformList[1][1]
          if (box.width)
            scale[0] = box.width / bb[2]
          if (box.height)
            scale[1] = box.height / bb[3]
          box.x = -(-bb[0]*scale[0] + box.cx)
          box.y = -(-bb[1]*scale[1] + box.cy)
          cornerPoints.left.set('x', box.x+box.cx)
          cornerPoints.top.set('y', box.y+box.cy)
          cornerPoints.right.set('x', box.x+box.cx+box.width)
          cornerPoints.bottom.set('y', box.y+box.cy+box.height)
          cr.x = box.x + box.cx + box.width / 2
          cr.y = box.y + box.cy + box.height / 2
        }, false)
        obj_container.appendChild(cp)
        cp.vside = (i % 2 == 0) ? 'top' : 'bottom'
        cp.vfriends = cornerPoints[cp.vside]
        cp.vfriends.push(cp)
        cp.hside = (i / 2 < 1) ? 'left' : 'right'
        cp.hfriends = cornerPoints[cp.hside]
        cp.hfriends.push(cp)
      }
      obj_container.append(box)

      return w
    }
  })
  Effects.add('TransformWidgetProto')


  DesignSketching = CakeJS.Klass(Effect, {
    description : 'Heavily unoptimized, drag with mouse to pan. See also <a href="redesign.html">this full-size version</a>.',
    
    initialize : function(c,cc) {
      Effect.initialize.apply(this, arguments)
      this.canvas.fill = 'white'
      SVGParser.load('cakenu2.svg', {
        width: 640,
        height: 480,
        onSuccess: this.initDesign.bind(this),
        onFailure: function(xhr, e){ console.log(arguments) }
      })
      var th = this
      this.canvas.addEventListener('mousedown', function(ev) {
        th.dragX = this.root.mouseX
        th.dragY = this.root.mouseY
        th.dragging = true
        return false
      }, true)
      this.canvas.addEventListener('mousemove', function(ev) {
        if (th.dragging) {
          var dx = this.root.mouseX - th.dragX
          var dy = this.root.mouseY - th.dragY
          th.dragX = this.root.mouseX
          th.dragY = this.root.mouseY
          th.scene.x += dx
          th.scene.y += dy
        }
        return false
      }, true)
      this.canvas.addEventListener('mouseup', function(ev) {
        th.dragging = false
        return false
      }, true)
    },

    initDesign : function(svg) {
      this.design = svg
      this.scene.scale = 640 / 1024

      this.splash = svg.$('splash')
      this.splash = svg.defs.splash
      this.monolith = svg.defs.monolith
      this.navi = svg.defs.navi
      this.naviShadow = svg.defs.navi_shadow
      this.cake = svg.defs.cake
      this.source = svg.defs.source
      this.sourceArea = svg.defs.source_area
      this.sourceArea.fill = false
      this.screen = svg.defs.screen
      this.screenClip = svg.defs.screen_clip
      this.screenClip.clip = true
      this.screenClip.fill = false
     
      var bottomLayer = new Canvas(E.canvas(640, 480), {
        isPlaying : false,
        changed : true,
        redrawOnlyWhenChanged : true
      })
      this.bottomImage = new ImageNode(bottomLayer.canvas, {zIndex : -1})
      
      var topLayer = new Canvas(E.canvas(640, 480), {
        isPlaying : false,
        changed : true,
        redrawOnlyWhenChanged : true
      })
      this.topImage = new ImageNode(topLayer.canvas, {zIndex : 1})

      topLayer.scale = bottomLayer.scale = this.scene.scale
      this.topImage.scale = this.bottomImage.scale = 1/this.scene.scale
      topLayer.append(this.monolith, this.navi, this.cake, this.source, this.naviShadow)
      bottomLayer.append(this.splash, this.screen)

      topLayer.onFrame()
      bottomLayer.onFrame()

      var bb = this.screenClip.getBoundingBox()
      var ce = E.canvas(Math.ceil(bb[2]),Math.ceil(bb[3]))
      var canvas = new Canvas(ce, {isPlaying:false})
      this.circles = new Circles(canvas, this.controlContainer)
      var tn = new CanvasNode()
      tn.append(this.circles.scene)
      canvas.append(tn)
      var top = new ImageNode(ce)
      top.addFrameListener(canvas.onFrame.bind(canvas))
      top.x += Math.floor(bb[0]) - 1
      top.y += Math.floor(bb[1])
      this.screenClip.append(top)
      this.screenClip.zIndex = 0
      this.screenClip.fill = false
      var ta = E('textarea', {
        style: {
          width : this.sourceArea.width + 'px',
          height : this.sourceArea.height + 'px'
        }
      })
      ta.value = Object.toSource(Circles.prototype)
      var en = new ElementNode(ta)
      this.sourceText = en
//       this.sourceArea.append(en)
//       this.sourceArea.display = 'none'
      this.screenClip.opacity = 0
      this.screenClip.after(1000, function(){
        this.animate('opacity', 0, 0.9, 3000, 'sine')
      })
//       this.scene.append(svg)

      this.scene.append(this.screenClip)
      this.scene.append(this.bottomImage)
      this.scene.append(this.topImage)

    }

  })
  Effects.add('DesignSketching')


  AudioTest = CakeJS.Klass(Effect, {
    description : "Test for AudioNodes. Pan sound by dragging.<br><br>Sounds from <a href=\"http://freesound.iua.upf.edu/\">The Freesound Project</a><br>sound1.mp3: <a href=\"http://freesound.iua.upf.edu/samplesViewSingle.php?id=21932\">20060810.seagulls.flac</a> by <a href=\"http://freesound.iua.upf.edu/usersViewSingle.php?id=8043\">dobroide</a><br>sound2.mp3: <a href=\"http://freesound.iua.upf.edu/samplesViewSingle.php?id=24586\">Jackdaws.flac</a> by <a href=\"http://freesound.iua.upf.edu/usersViewSingle.php?id=37876\">acclivity</a><br>sound3.mp3: <a href=\"http://freesound.iua.upf.edu/samplesViewSingle.php?id=13536\">TawnyOwl2.wav</a> by <a href=\"http://freesound.iua.upf.edu/usersViewSingle.php?id=37876\">acclivity</a>",

    initialize : function() {
      Effect.initialize.apply(this, arguments)
      var button1 = this.makeSoundButton('sound1.mp3', 320, 120)
      var button2 = this.makeSoundButton('sound2.mp3', 200, 320)
      var button3 = this.makeSoundButton('sound3.mp3', 440, 320)
      this.scene.append(button1, button2, button3)
    },

    makeSoundButton : function(src, x, y) {
      var cn = new CanvasNode({x:x, y:y})
      var dragHandle = new Circle(10, {fill: '#dddddd', x:40, y: -40, opacity: 0.8, cursor: 'move'})
      dragHandle.when('drag', function(ev) {
        cn.x += ev.dx
        cn.y += ev.dy
      })
      var c = new Circle(40, {fill: '#dddddd'})
      c.opacity = 0.8
      c.cursor = 'pointer'
      c.when('mouseover', function(){ this.opacity = 1 })
      c.when('mouseout', function(){ this.opacity = 0.8 })
      var el = new ElementNode(src, {color: 'white', x:50, valign:'center'})
      var elbg = new Rectangle(100, 20, {x:40, y:-10, rx:10, zIndex:-1, fill:'#33363C', opacity:0.8})
      elbg.afterFrame(1, function(){
        this.width = el.eWidth+20
      })
      var a = new AudioNode(src, {transformSound : true})
      var play = new Polygon([30, 0, -20, -20, -20, 20], {fill: 'black', opacity: 0.3})
      a.when('ready', function(){ play.animateTo('opacity', 1, 800, 'square') })
      a.when('error', function(){
        play.append(new Rectangle(50, 10, {fill:'darkred', absoluteOpacity: 1, centered: true, rotation: Math.PI/4}))
        play.append(new Rectangle(50, 10, {fill:'darkred', absoluteOpacity: 1, centered: true, rotation: -Math.PI/4}))
        c.addEventListener('click', function(ev) { return false }, true)
      })
      var pause = new CanvasNode({fill: 'black', visible: false})
      pause.append(
        new Rectangle(18, 40, {centered: true, x: -12}),
        new Rectangle(18, 40, {centered: true, x: 12})
      )
      c.append(play, pause, a)
      cn.append(c, el, elbg, dragHandle)
      c.addEventListener('click', function(){
        if (a.playing) a.pause()
        else a.play()
      })
      var playButton = function() {
        play.visible = true
        pause.visible = false
      }
      var pauseButton = function() {
        play.visible = false
        pause.visible = true
      }
      c.when('pause', playButton)
      c.when('stop', playButton)
      c.when('play', pauseButton)
      return cn
    }
  })
  Effects.add('AudioTest')

  KeyframeTest = CakeJS.Klass(Effect, {
    description : "Keyframe animation test.",

    initialize : function() {
      Effect.initialize.apply(this, arguments)
      var c = new Circle(20, {fill: [192,192,192,1], stroke: 'gray'})
      var move = new Timeline()
      move.addKeyframe(0, {x: 0, y: 0})
      move.addKeyframe(2000, {x: 100, y: 200}, 'sine')
      move.addKeyframe(4000, {x: 100, y: 200}, 'set')
      move.addKeyframe(7000, {x: 500, y: 200}, 'sine')
      c.addTimeline(move)
      var shape = new Timeline()
      shape.addKeyframe(1600, {radius: 20, strokeWidth: 1})
      shape.addKeyframe(3000, {radius: 40, strokeWidth: 1}, 'sproing')
      shape.addKeyframe(4000, {radius: 40, strokeWidth: 10}, 'sproing')
      c.addTimeline(shape)
      var color = new Timeline()
      color.addKeyframe(6000, {fill: c.fill})
      color.addKeyframe(8000, {fill: [40,220,90,0.5]}, 'sine')
      c.addTimeline(color)
      this.scene.append(c)
    }
  })
  Effects.add('KeyframeTest')

  KeyboardTest = CakeJS.Klass(Effect, {
    description: 'Click on a shape to focus it, use the arrow keys to move it around.',
    
    initialize : function() {
      Effect.initialize.apply(this, arguments)
      this.canvas.redrawOnlyWhenChanged = true
      var c = new Circle(40, {fill: [40, 220, 90, 0.5]})
      c.x = 100
      c.y = 100
      var r = new Rectangle(80, 80, {fill: [220, 40, 90, 0.5]})
      r.x = 400
      r.y = 300
      var kb_move = function(t,dt) {
        if (this.focused) {
          var ox = this.x, oy = this.y
          if ( this.root.keys.left )
            this.x -= 10
          if ( this.root.keys.right )
            this.x += 10
          if (this.root.keys.up )
            this.y -= 10
          if (this.root.keys.down )
            this.y += 10
          this.changed = this.x != ox || this.y != oy
        }
        var nf = this.focused ? 0.75 : 0.5
        if (nf != this.fill[3]) {
          this.fill[3] = nf
          this.changed = true
        }
      }
      c.addFrameListener(kb_move)
      r.addFrameListener(kb_move)
      c.when('focus', function(){ this.focused = true })
      c.when('blur', function(){ this.focused = false })
      r.when('focus', function(){ this.focused = true })
      r.when('blur', function(){ this.focused = false })
      
      this.scene.when('keydown', function(ev) { ev.preventDefault() })
      this.scene.when('keypress', function(ev) { ev.preventDefault() })
      this.scene.when('keyup', function(ev) { ev.preventDefault() })
      this.scene.append(c,r)
    }
  })
  Effects.add('KeyboardTest')

</script>
<style type="text/css">
  body {
    background-color: #13161C;
    background-image: url(fhtrbgtile.png);
    color: #93969C;
    font-family: arial;
    font-size: 12px;
  }
  div {
    margin: 0;
    padding: 0;
  }
  #myCanvas {
    position: absolute;
    left: 0px;
    top: 0px;
  }
  #canvasContainer {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 640px;
    height: 480px;
    overflow: hidden;
  }
  #source {
    position: absolute;
    left: 0px;
    top: 480px;
    width: 640px;
    height: 340px;
    z-index: 1;
  }
  #sourceBg {
    position: absolute;
    left: 0px;
    top: 480px;
    width: 640px;
    height: 640px;
    background: black;
    opacity: 0.5;
    z-index: 0;
  }
  #source h3 {
    margin-left: 8px;
    margin-bottom: 4px;
  }
  #source textarea {
    margin-left: 8px;
    padding-left: 2px;
    width: 618px;
    height: 600px;
  }
  #sourceSubmit {
    position: absolute;
    right: 8px;
    top: 4px;
  }
  #controlPanel {
    position: absolute;
    left: 640px;
    top: 0px;
    width: 346px;
    min-height: 100%;
    background: #23262C;
    padding: 8px;
    padding-top: 0px;
    padding-right: 12px;
    padding-bottom: 32px;
    border-left: 1px solid #33363C;
    border-right: 1px solid #13161C;
  }
  #rightOverlay {
    position: fixed;
    left: 1008px;
    top: 0px;
    right: 0px;
    bottom: 0px;
    background: black;
    opacity: 0.5;
  }
  .Screenshots {
    margin-right: -4px;
  }
  .Screenshots img {
    margin: 6px;
    border: 1px solid #33363C;
  }
  input[type=checkbox] {
    margin-left: 0px;
  }
  select {
    margin-top: 2px;
  }
  .GuiConfigDescription {
    border-top: 1px solid #13161C;
    border-left: 1px solid #13161C;
    border-bottom: 1px solid #33363C;
    border-right: 1px solid #33363C;
    margin-bottom: 8px;
    background-color: #1A1D24;
    padding: 4px;
    padding-bottom: 6px;
  }
  hr {
    border-top: 1px solid #13161C;
    border-left: 1px solid #13161C;
    border-bottom: 1px solid #33363C;
    border-right: 1px solid #33363C;
    background-color: #1A1D24;
    margin-top: 12px;
    margin-bottom: 4px;
  }
  h3 {
    font-family: Helvetica, Arial;
    color: white;
    margin-top: 8px;
    margin-bottom: 8px;
  }
  p + h3 {
    margin-top: 18px;
  }
  h4 {
    font-family: Helvetica, Arial;
    color: white;
  }
  li h4 {
    display: inline;
  }
  p {
    margin-top: 0px;
    margin-bottom: 4px;
  }
  li {
    margin-bottom: 4px;
  }
</style>
<title>CAKE - Canvas Animation Kit Experiment</title>
</head>
<body vlink="#83668C" link="#A3A6FF">
  <div id="controlPanel">
    <h3>Controls</h3>
    <div id="effects"></div>
    <div id="controls"></div>
    <div id="debug"></div>
    <hr></hr>
    <div id="info">
      <h3>Download</h3>
      <p><a href="http://code.google.com/p/cakejs">CAKE on Google Code</a></p>
      <h3>About</h3>
      <p>
      <a href="http://code.google.com/p/cakejs">CAKE</a> is a scenegraph library for the <a href="http://www.whatwg.org/specs/web-apps/current-work/#canvas">canvas</a> tag. You could say that it's like SVG sans the XML and not be too far off. This page is a showcase of CAKE feature tests.
      </p>
      <h3>Things CAKE adds to canvas</h3>
      <ul>
        <li>Keeps track of the current transformation matrix [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=408804">bug</a>]. Basically duplicating canvas's entire transformation system.</li>
        <li>Fixes Firefox's isPointInPath() [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=405300">bug</a>, WONTFIX]. Implements isPointInPath on browsers that lack it (Safari [<a href="http://bugs.webkit.org/show_bug.cgi?id=16629">bug</a>, FIXED], Opera 9.2), with accurate tests for circles and rectangles, and inaccurate bounding box test for paths.</li>
        <li>Implements transform() and setTransform() (thanks <a href="http://dojotoolkit.org">dojo</a>) on browsers that don't have them (Firefox 2, Safari [<a href="http://bugs.webkit.org/show_bug.cgi?id=16604">bug</a>].)</li>
        <li>Transforms for patterns and gradients, SVG-style. Probably doesn't work on Opera. A pattern-space transformation matrix would be nice.</li>
      </ul>
      <h3>Platforms tested</h3>
      <ul>
        <li>Linux x86 (64-bit): Firefox 2, Firefox 3b</li>
        <li>iPhone: Safari</li>
        <li>Linux x86 (32-bit): Firefox 2</li>
        <li>Windows XP: Firefox 2, Firefox 3b, Safari 3b, Opera 9.5b</li>
      </ul>
      <h3>Browser support</h3>
      <ul>
        <li><h4>Firefox 3 beta</h4> weird choppiness on x86_64 Linux [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=408372">bug</a>], no drop shadows [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=310682">bug</a>], globalAlpha doesn't affect patterns [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=401790">bug</a>], mozDrawText API lacks a way to get the font height and baseline [<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=406117">bug</a>]</li>
        <li><h4>Firefox 2.0</h4> no text, non-pattern images are slow, no drop shadows, globalAlpha doesn't affect patterns</li>
        <li><h4>Safari 3</h4> no toDataURL [<a href="http://bugs.webkit.org/show_bug.cgi?id=16673">bug</a>, FIXED], no text, no-repeat image patterns break when transforming [<a href="http://bugs.webkit.org/show_bug.cgi?id=16516">bug</a>, FIXED], linear gradients get ugly when rotating [<a href="http://bugs.webkit.org/show_bug.cgi?id=16627">bug</a>, <a href="http://bugs.webkit.org/show_bug.cgi?id=16045">maybe related</a>], <b>runs like a bat out of hell</b></li>
        <li><h4>Opera 9.5 beta</h4> no text, no drop shadows, some broken (and slow) composite operations, scaled circle strokes are buggy (small gap between first and last point)</li>
        <li><h4>Opera 9.2</h4> some basic features work, scaled circle strokes are buggy, slow</li>
        <li><h4>IE</h4> a couple things work with <a href="http://excanvas.sf.net">ExplorerCanvas</a> but it gets VERY SLOW after a few hundred frames</li>
      </ul>
      <h3>Canvas wishlist, roughly in order of importance</h3>
      <ul>
        <li>Access to the current transformation matrix</li>
        <li>Pattern-space transformation matrix</li>
        <li>Masks</li>
        <li>SVG filters</li>
        <li>A text API with: CSS style object as ctx.style (not string), text as path, text along path [as path], font metrics, fast selection path with text bbox rectangles</li>
        <li>Groups (like in Cairo)</li>
        <li>Fast pixel access (JavaScript is slow, converting JS data to native data is slow)</li>
        <li>Conical gradients, object space gradients, repeating gradients, mirrored gradients, <a href="http://www.ic.al.lg.ua/~ksv/gimpdoc-html/paint.html">etc.</a></li>
        <li>More <a href="http://www.pegtop.net/delphi/articles/blendmodes/index.htm">blend modes</a>. At least multiply, screen, darken, lighten, color and value. Overlay would be nice too. Maybe soft light, difference, dodge and burn as well.</li>
        <li>SVG fill rules</li>
        <li>isPointInStroke</li>
        <li>drawElement for drawing HTML elements</li>
        <li>Dashed strokes</li>
        <li>Rename 'lighter' to 'add' and 'darker' to 'subtract'.</li>
      </ul>
      <h3>Contact</h3>
      <p>Email: ilmari.heikkinen gmail com</p>
    </div>
  </div>
  <div id="canvasContainer">
    <canvas width="640" height="480" id="myCanvas"></canvas>
  </div>
  <div id="source">
    <h3>Effect source</h3>
    <form>
    <textarea id="sourceText">
    </textarea>
    <input id="sourceSubmit" type="submit" value="Apply changes"></input>
    </form>
  </div>
  <div id="sourceBg"></div>
  <script type="text/javascript">
  	soundManager.createMovie();
  </script>
  <script type="text/javascript">
    window.effects = new Effects($('myCanvas'), $('effects'), $('controls'))
  </script>
</body>
</html>
